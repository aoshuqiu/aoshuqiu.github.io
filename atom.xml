<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>3号列车</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.aoshuqiu.top/"/>
  <updated>2021-02-01T09:10:15.914Z</updated>
  <id>https://www.aoshuqiu.top/</id>
  
  <author>
    <name>三儿</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GCPN环境搭建时对rl-baselines中环境的更改</title>
    <link href="https://www.aoshuqiu.top/2021/02/01/GCPN%E4%B8%ADrl-baselines%E7%8E%AF%E5%A2%83%E7%9A%84%E6%9B%B4%E6%94%B9/"/>
    <id>https://www.aoshuqiu.top/2021/02/01/GCPN%E4%B8%ADrl-baselines%E7%8E%AF%E5%A2%83%E7%9A%84%E6%9B%B4%E6%94%B9/</id>
    <published>2021-02-01T08:54:10.000Z</published>
    <updated>2021-02-01T09:10:15.914Z</updated>
    
    <content type="html"><![CDATA[<p>《Graph Convolutional Policy Network for Goal-Directed Molecular Graph Generation》</p><p>这篇论文在github中给出了源码：</p><p><a href="https://github.com/bowenliu16/rl_graph_generation">https://github.com/bowenliu16/rl_graph_generation</a></p><p>但在环境配置时出现了问题，原因是其中gym的mujoco模块没能成功安装。</p><p><img src="/2021/02/01/GCPN%E4%B8%ADrl-baselines%E7%8E%AF%E5%A2%83%E7%9A%84%E6%9B%B4%E6%94%B9/image-20210201170047454.png" alt="image-20210201170047454"></p><a id="more"></a><p>可以看到在gym中要求安装mujoco模块，而在实际的代码设计中没有用到mujoco的东西，</p><p>而下面的tensorflow要求为&gt;=1.4.0 然而目前TensorFlow已经更新了2.0版本，其中有大部分函数的修改，直接运行很有可能安装到最新版本。</p><p><img src="/2021/02/01/GCPN%E4%B8%ADrl-baselines%E7%8E%AF%E5%A2%83%E7%9A%84%E6%9B%B4%E6%94%B9/image-20210201170402483.png" alt="image-20210201170402483"></p><p>将gym行删掉，改为自己用命令行conda install gym 安装gym</p><p>下面的tensorflow改成&lt;2.0 它会安装最近的符合这个标准的tf</p><p>其他的按照网站中的搭建步骤搭建即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Graph Convolutional Policy Network for Goal-Directed Molecular Graph Generation》&lt;/p&gt;
&lt;p&gt;这篇论文在github中给出了源码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bowenliu16/rl_graph_generation&quot;&gt;https://github.com/bowenliu16/rl_graph_generation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但在环境配置时出现了问题，原因是其中gym的mujoco模块没能成功安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/02/01/GCPN%E4%B8%ADrl-baselines%E7%8E%AF%E5%A2%83%E7%9A%84%E6%9B%B4%E6%94%B9/image-20210201170047454.png&quot; alt=&quot;image-20210201170047454&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://www.aoshuqiu.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="毕业设计" scheme="https://www.aoshuqiu.top/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="mujoco" scheme="https://www.aoshuqiu.top/tags/mujoco/"/>
    
      <category term="环境搭建" scheme="https://www.aoshuqiu.top/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>PPO</title>
    <link href="https://www.aoshuqiu.top/2021/01/19/PPO/"/>
    <id>https://www.aoshuqiu.top/2021/01/19/PPO/</id>
    <published>2021-01-19T08:50:21.000Z</published>
    <updated>2021-01-19T10:25:39.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PPO"><a href="#PPO" class="headerlink" title="PPO"></a>PPO</h1><p>TRPO的最终替代函数为：</p><script type="math/tex; mode=display">L^{CPI}(\theta)=\mathbb{E}_t\bigg[ \frac{\tilde\pi_\theta(a_t|s_t)}{\pi_{\theta_{old}}(a_t|s_t) }A_t\bigg]</script><p>因为用到了重要性采样，保留了之前策略的动作与状态分布，CPI（Conservation Policy Iteration）保留策略迭代。</p><p>记概率比值$r_t(\theta) = \frac{\tilde\pi_\theta(a_t|s_t)}{\pi_{\theta_{old}}(a_t|s_t) }$，得到$L^{CPI}(\theta)=\mathbb{E}_t\big[ r_t(\theta)A_t\big]$</p><p><strong>问题</strong></p><p>没有约束条件的话，最大化$L^{CPI}$会导致大幅度的策略更新，因此要想办法通过改变目标函数，来对那些$r_t(\theta)$项离1很远的情况进行惩罚。</p><a id="more"></a><p><strong>解决</strong></p><p>PPO提出了一种替代函数的替代</p><p>$L^{CLIP}(\theta)=\mathbb{E}_t\big[\min(r_t(\theta)A_t,clip(r_t(\theta),1-\epsilon,1+\epsilon)A_t)\big]$</p><p>通过其中的clip裁剪，来去掉最大化TRPO替代函数时大幅度改变$r_t(\theta)$的倾向。也就是说只保留那些使目标更好的比值变化，舍弃那些使目标变坏但靠着比值增大硬拉替代函数值的比值变化。</p><p>通过取小值来保证它是裁剪前函数的下界，来达到最大化下界的目的。</p><p><img src="/2021/01/19/PPO/image-20210119175132551.png" alt="image-20210119175132551"></p><p>上图是在特定t下的裁剪情况，其中左图代表正奖励时的裁剪，右图代表负奖励时的裁剪</p><p>还有一种自适应改变步长的替代方法，首先它采用的是带KL散度惩罚的替代函数</p><p>$L^{KLPEN}(\theta) = \mathbb{E}\bigg[\frac{\pi_\theta(a_t|s_t)}{\pi_{\theta_{old}}(a_t|s_t)}A_t-\beta KL[\pi_{\theta_{old}}(\cdot | s_t),\pi_{\theta}(\cdot | s_t)]\bigg]$</p><p>在每次小集群的随机梯度下降中，计算一个$d = \mathbb{E}_t[KL[\pi_{\theta_{old}}(\cdot | s_t),\pi_{\theta}(\cdot | s_t)]]$</p><ul><li>如果$d&lt; d_{targ}/1.5$，那么$ \beta \leftarrow \beta/2$</li><li>如果$d&gt; d_{targ} \times 1.5$，那么$ \beta \leftarrow \beta \times 2$</li></ul><p>更新后的步长$\beta$ 用于下一次的策略更新，1.5和2是通过启发性选择得到的。初始步长也是一个超参，不过无关紧要，因为步长会被很快地调整。</p><p>这种方法并没有上一种CLIP的效果好，所以通常还是使用上面的CLIP替代。</p><p><img src="/2021/01/19/PPO/aHR0cDovLzViMDk4OGU1OTUyMjUuY2RuLnNvaHVjcy5jb20vaW1hZ2VzLzIwMTkwMjAyLzg4YWRkZjZiMjkzMzQ3Yjc5NDI1YWYzYjMzZDg4MDE1LmpwZWc" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PPO&quot;&gt;&lt;a href=&quot;#PPO&quot; class=&quot;headerlink&quot; title=&quot;PPO&quot;&gt;&lt;/a&gt;PPO&lt;/h1&gt;&lt;p&gt;TRPO的最终替代函数为：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;L^{CPI}(\theta)=\mathbb{E}_t\bigg[ \frac{\tilde\pi_\theta(a_t|s_t)}{\pi_{\theta_{old}}(a_t|s_t) }A_t\bigg]&lt;/script&gt;&lt;p&gt;因为用到了重要性采样，保留了之前策略的动作与状态分布，CPI（Conservation Policy Iteration）保留策略迭代。&lt;/p&gt;
&lt;p&gt;记概率比值$r_t(\theta) = \frac{\tilde\pi_\theta(a_t|s_t)}{\pi_{\theta_{old}}(a_t|s_t) }$，得到$L^{CPI}(\theta)=\mathbb{E}_t\big[ r_t(\theta)A_t\big]$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;没有约束条件的话，最大化$L^{CPI}$会导致大幅度的策略更新，因此要想办法通过改变目标函数，来对那些$r_t(\theta)$项离1很远的情况进行惩罚。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://www.aoshuqiu.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://www.aoshuqiu.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="强化学习" scheme="https://www.aoshuqiu.top/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TRPO" scheme="https://www.aoshuqiu.top/tags/TRPO/"/>
    
  </entry>
  
  <entry>
    <title>TRPO</title>
    <link href="https://www.aoshuqiu.top/2021/01/16/TRPO/"/>
    <id>https://www.aoshuqiu.top/2021/01/16/TRPO/</id>
    <published>2021-01-16T13:34:10.000Z</published>
    <updated>2021-01-19T09:21:27.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TRPO"><a href="#TRPO" class="headerlink" title="TRPO"></a>TRPO</h1><h3 id="重要性采样"><a href="#重要性采样" class="headerlink" title="重要性采样"></a>重要性采样</h3><p>原理：</p><p>$\mathbb{E}_{x \sim p(x)}[f(x)] = \int p(x)f(x)\, {\rm d}x = \int q(x)\frac{p(x)}{q(x)}f(x)\,{\rm d}x = \mathbb{E}_{x \sim q(x)}[\frac{p(x)}{q(x)}f(x)] $</p><p>从q(x)中采样来替代从p(x)中采样</p><p><strong>修改：</strong></p><p>应用到目标函数</p><p>$ J(\theta) = \mathbb{E}_{\tau \sim p_{\theta}(\tau)}[r(\tau)] = \mathbb{E}_{\tau \sim p_{\theta^{old}}(\tau)}\bigg[\frac{p_{\theta}(\tau)}{p_{\theta^{old}}(\tau) }r(\tau)\bigg]$</p><p>比值项</p><p>$\frac{p_{\theta}(\tau)}{p_{\theta^{old}}(\tau)} = \frac{p(s_{1})\prod \limits_{t=1}^{T}\pi_{\theta}(a_{t}|s_{t})p(s_{t+1}|s_{t},a_{t})}{p(s_{1})\prod \limits_{t=1}^{T}\pi_{\theta^{old}}(a_{t}|s_{t})p(s_{t+1}|s_{t},a_{t})} = \frac{\prod \limits_{t=1}^{T}\pi_{\theta}(a_{t}|s_{t})}{\prod \limits_{t=1}^{T}\pi_{\theta^{old}}(a_{t}|s_{t})}$</p><p>得出</p><p>$\nabla_{\theta}J(\theta) = \mathbb{E}_{\tau \sim p_{\theta}(\tau)}\bigg[\sum \limits_{t=1}^{T} \nabla_{\theta} log \pi_{\theta}(a_t|s_t)\bigg(\prod \limits_{t’=1}^{t} \frac{\pi_{\theta}(a_{t’}|s_{t’})}{\pi_{\theta^{old}}(a_{t’}|s_{t’})}\bigg)\bigg(\sum \limits_{t’ =t}^{T}r(s_{t’},a_{t’})-b\bigg)\bigg]$</p><p>连乘可能趋于0’<br><a id="more"></a></p><h2 id="MM"><a href="#MM" class="headerlink" title="MM"></a>MM</h2><p>Majorize-Minimization 最小化上界函数</p><p>Minorize-Maximization 最大化下界函数</p><h2 id="Surrogate-function"><a href="#Surrogate-function" class="headerlink" title="Surrogate function"></a>Surrogate function</h2><p>原目标函数非凸，很难优化，求解逼近于目标函数的替代函数，不断迭代替代函数。</p><p>目标函数：策略的期望折扣奖励</p><p>替代函数：是目标函数的下界函数，可用于估计当前策略的期望奖励，易于优化</p><h2 id="TRPO-1"><a href="#TRPO-1" class="headerlink" title="TRPO"></a>TRPO</h2><p>策略梯度中，参数的更新为$\theta_{new} = \theta_{old}+\alpha \nabla_{\theta}J$</p><p>这种方法对于步长$\alpha$的选取很难控制，如果步长不合适，可能会导致目标函数反而越来越差。</p><p><strong>目标</strong>： 找到一个合适的步长，使每次更新时目标函数都单调递增。</p><p><strong>方法</strong>：希望目标函数（期望回报函数）单调递增，那么可以将新策略的期望回报函数分解成原有策略回报函数加一个永远为正的项。</p><p>得到等式</p><p>$\eta(\tilde{\pi})=\eta(\pi)+\mathbb{E}_{\tau \in \tilde{\pi}}\bigg[\sum \limits^{\infty}_{t=0}A_\pi(s_t,a_t)\bigg]$</p><p>其中</p><p><img src="/2021/01/16/TRPO/q与v.png" alt="q与v" style="zoom:33%;"></p><p>$A_\pi(s,a)=Q_\pi(s,a) - V_\pi(s)=\mathbb{E}_{s’\sim P(s’|s,a)}[r(s)+\gamma V^\pi(s’)-V^\pi(s)]$</p><p>其中r(s) 即为R(s,a,s’)</p><p>公式证明：</p><script type="math/tex; mode=display">\begin{align*}&\mathbb{E}_{\tau \sim \tilde{\pi}}\bigg[\sum \limits^\infty_{t=0} \gamma^tA^\pi(s_t,a_t)\bigg]\\&= \mathbb{E}_{\tau \sim \tilde{\pi}}\bigg[\sum \limits^\infty_{t=0} \gamma^t(R(s_t,a_t,s_{t+1})+\gamma V^\pi(s_{t+1})-V^\pi(s_t))\bigg]\\&=\eta(\tilde{\pi})+\mathbb{E}_{\tau \sim \tilde{\pi}}\bigg[(\sum \limits^\infty_{t=0} \gamma^{t+1} V^\pi(s_{t+1})-\sum \limits^\infty_{t=0} \gamma^tV^\pi(s_t))\bigg]\\&=\eta(\tilde{\pi})+\mathbb{E}_{\tau \sim \tilde{\pi}}\bigg[(\sum \limits^\infty_{t=1} \gamma^{t} V^\pi(s_{t})-\sum \limits^\infty_{t=0} \gamma^tV^\pi(s_t))\bigg]\\&=\eta(\tilde{\pi})-\mathbb{E}_{\tau \sim \tilde{\pi}}\bigg[V^\pi(s_0)\bigg]\\&= \eta(\tilde{\pi})-\eta(\pi)\end{align*}</script><p>将公式写开得到：</p><p>$\eta(\tilde{\pi})=\eta(\pi)+\sum \limits^{\infty}_{t=0} \sum \limits_{s}P(s_t = s|\tilde{\pi})\sum \limits_{a}\tilde{\pi}(a|s)\gamma^tA_\pi(s,a)$</p><p>进一步变形:</p><p>$\eta(\tilde{\pi})=\eta(\pi)+ \sum \limits_{s}\rho_{\tilde{\pi}}(s)\sum \limits_{a}\tilde{\pi}(a|s)\gamma^tA_\pi(s,a)$</p><p>$\rho_\pi(s)=P(s_0=s)+\gamma P(s_1=s)+\gamma^2P(s_2=s)+…+\gamma^t(s_t=s)$</p><p>其中$\rho_{\tilde{\pi}}(s)$是新策略下的动态特性，但新策略此时还未知，且旧策略与新策略之间改动不大，因此用旧策略$\rho_{\pi}(s)$代替新策略。</p><p>在动作分布上利用重要性采样</p><p>$\sum \limits_{a} \tilde{\pi}_{\theta}(a|s_n)A_{\theta_{old}}(s_n,a)=\mathbb{E}_{a \sim q_{old}}\bigg[\frac{\tilde\pi_\theta(a|s_n) }{\pi_{\theta_{old}}(a|s_n) }A_{\theta_{old}(s_n,a)}\bigg]$</p><p>q为旧参数下的动作分布</p><p>记</p><p>$L_\pi(\tilde{\pi})=\eta(\pi)+\mathbb{E}_{s \sim \rho_{\theta_{old}},a \sim \pi_{\theta_{old}}}\bigg[\frac{\tilde\pi_\theta(a|s_n) }{\pi_{\theta_{old}}(a|s_n) }A_{\theta_{old}(s_n,a)}\bigg]$</p><p>引入不等式来取目标回报函数的下界，之后最大化下界</p><p>$\eta(\tilde \pi) \ge L_\pi(\tilde \pi) - CD^{max}_{KL}(\pi,\tilde \pi)$</p><p>其中$C = \frac {4 \in \gamma}{(1-\gamma)^2}$</p><p>$D^{max}_{KL}(\pi,\tilde \pi)$为固定状态下动作分布kl散度的最大值</p><p>但很难在每个策略下找到KL散度的最大值，因此使用KL散度的均值</p><p>$\bar{D}^{\rho_{\theta_{old}}}_{KL}(\pi,\tilde \pi) = \mathbb{E}_{s \sim \rho}[D_{KL}(\pi(\cdot|s)||\tilde\pi(\cdot|s))]$</p><p>记$M_i(\pi) = L_{\pi_i}(\tilde \pi)-C\bar{D}^{\rho_{\theta_{old}}}_{KL}(\pi,\tilde \pi)$</p><p>容易得到 $\eta(\pi_{i+1}) \ge M_i(\pi_{i+1})$且$\eta(\pi_i)=M_i(\pi_i)$</p><p>则 $\eta(\pi_{i+1})-\eta(\pi_{i}) \ge M_i(\pi_{i+1})-M_i(\pi_{i})$</p><p>那么，寻找使Mi最大的策略即可以保证策略的期望回报单调递增，那么寻找策略的过程就是一个不断寻找Mi最大值的过程</p><p>$\max \limits_{\theta}[L_{\theta_{old}}-C\bar{D}^{\rho_{\theta_{old}}}_{KL}(\theta_{old},\theta)]$</p><p><strong>最终得到</strong></p><p>为了使问题更加可解，将问题等效为</p><p>$\max \limits_{\theta}\mathbb{E}_{s \sim \rho_{\theta_{old}},a \sim \pi_{\theta_{old}}}\bigg[\frac{\tilde\pi_\theta(a|s_n) }{\pi_{\theta_{old}}(a|s_n) }A_{\theta_{old}(s_n,a)}\bigg]$ 满足约束$\bar{D}^{\rho_{\theta_{old}}}_{KL}(\theta_{old},\theta) \le \eta$</p><p><strong>理解</strong></p><p>在不断更新$\theta$的同时，替代函数也在不断逼近目标函数，最终会达到一个局部最优解</p><p><img src="/2021/01/16/TRPO/image-20210116190815243.png" alt="image-20210116190815243" style="zoom:33%;"><img src="/2021/01/16/TRPO/image-20210116190833276.png" alt="image-20210116190815243" style="zoom:33%;"></p><p>迭代更新过程</p><p><img src="/2021/01/16/TRPO/aHR0cDovLzViMDk4OGU1OTUyMjUuY2RuLnNvaHVjcy5jb20vaW1hZ2VzLzIwMTkwMjAyLzRlYzk5YTEwNDIzMTRlMDJiMGMyZTU4NTM4YTMzNjBiLmpwZWc" alt="img"></p><p>参考博客：</p><p><a href="https://blog.csdn.net/tanjia6999/article/details/99716133">https://blog.csdn.net/tanjia6999/article/details/99716133</a></p><p><a href="https://blog.csdn.net/weixin_41679411/article/details/82421121">https://blog.csdn.net/weixin_41679411/article/details/82421121</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TRPO&quot;&gt;&lt;a href=&quot;#TRPO&quot; class=&quot;headerlink&quot; title=&quot;TRPO&quot;&gt;&lt;/a&gt;TRPO&lt;/h1&gt;&lt;h3 id=&quot;重要性采样&quot;&gt;&lt;a href=&quot;#重要性采样&quot; class=&quot;headerlink&quot; title=&quot;重要性采样&quot;&gt;&lt;/a&gt;重要性采样&lt;/h3&gt;&lt;p&gt;原理：&lt;/p&gt;
&lt;p&gt;$\mathbb{E}_{x \sim p(x)}[f(x)] = \int p(x)f(x)\, {\rm d}x = \int q(x)\frac{p(x)}{q(x)}f(x)\,{\rm d}x = \mathbb{E}_{x \sim q(x)}[\frac{p(x)}{q(x)}f(x)] $&lt;/p&gt;
&lt;p&gt;从q(x)中采样来替代从p(x)中采样&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用到目标函数&lt;/p&gt;
&lt;p&gt;$ J(\theta) = \mathbb{E}_{\tau \sim p_{\theta}(\tau)}[r(\tau)] = \mathbb{E}_{\tau \sim p_{\theta^{old}}(\tau)}\bigg[\frac{p_{\theta}(\tau)}{p_{\theta^{old}}(\tau) }r(\tau)\bigg]$&lt;/p&gt;
&lt;p&gt;比值项&lt;/p&gt;
&lt;p&gt;$\frac{p_{\theta}(\tau)}{p_{\theta^{old}}(\tau)} = \frac{p(s_{1})\prod \limits_{t=1}^{T}\pi_{\theta}(a_{t}|s_{t})p(s_{t+1}|s_{t},a_{t})}{p(s_{1})\prod \limits_{t=1}^{T}\pi_{\theta^{old}}(a_{t}|s_{t})p(s_{t+1}|s_{t},a_{t})} = \frac{\prod \limits_{t=1}^{T}\pi_{\theta}(a_{t}|s_{t})}{\prod \limits_{t=1}^{T}\pi_{\theta^{old}}(a_{t}|s_{t})}$&lt;/p&gt;
&lt;p&gt;得出&lt;/p&gt;
&lt;p&gt;$\nabla_{\theta}J(\theta) = \mathbb{E}_{\tau \sim p_{\theta}(\tau)}\bigg[\sum \limits_{t=1}^{T} \nabla_{\theta} log \pi_{\theta}(a_t|s_t)\bigg(\prod \limits_{t’=1}^{t} \frac{\pi_{\theta}(a_{t’}|s_{t’})}{\pi_{\theta^{old}}(a_{t’}|s_{t’})}\bigg)\bigg(\sum \limits_{t’ =t}^{T}r(s_{t’},a_{t’})-b\bigg)\bigg]$&lt;/p&gt;
&lt;p&gt;连乘可能趋于0’&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://www.aoshuqiu.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://www.aoshuqiu.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="强化学习" scheme="https://www.aoshuqiu.top/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TRPO" scheme="https://www.aoshuqiu.top/tags/TRPO/"/>
    
  </entry>
  
  <entry>
    <title>GCPN 图卷积策略网络分子生成</title>
    <link href="https://www.aoshuqiu.top/2021/01/13/GCPN/"/>
    <id>https://www.aoshuqiu.top/2021/01/13/GCPN/</id>
    <published>2021-01-13T06:23:10.000Z</published>
    <updated>2021-02-03T06:03:41.724Z</updated>
    
    <content type="html"><![CDATA[<p>《Graph Convolutional Policy Network for Goal-Directed Molecular Graph Generation》</p><h2 id="GCPN"><a href="#GCPN" class="headerlink" title="GCPN"></a>GCPN</h2><h3 id="应用目标导向"><a href="#应用目标导向" class="headerlink" title="应用目标导向"></a>应用目标导向</h3><ol><li>分子空间大：$10^{60}$</li><li>化学空间离散，分子性质对微小的结构改变也很敏感</li></ol><h2 id="GCPN-1"><a href="#GCPN-1" class="headerlink" title="GCPN"></a>GCPN</h2><ol><li>图卷积策略网络，引导生成特定期望目标同时用基本化学规则限制输出空间</li><li>图表示+强化学习+对抗训练</li></ol><a id="more"></a><h2 id="图表示"><a href="#图表示" class="headerlink" title="图表示"></a>图表示</h2><ol><li>部分图代表子结构 部分字符代表不了</li><li>生成过程中可以进行化学检查</li></ol><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><h4 id="1-期望分子性质与约束复杂且不可微"><a href="#1-期望分子性质与约束复杂且不可微" class="headerlink" title="1. 期望分子性质与约束复杂且不可微"></a>1. 期望分子性质与约束复杂且不可微</h4><p> 为什么？ </p><p>​            <strong>分子性质对微小的结构改变也很敏感</strong>，</p><p>​            可微：相似分子性质相似</p><p>​            事实：同分异构体都可能有完全相反的性质</p><p>​    导致？</p><p>​            不能直接通过目标函数表示这些性质</p><p>​    生成模型通过生成器生成策略（序列生成）来解决</p><p>​    强化学习用动态性质与奖励函数表示：不需要性质可微</p><h4 id="2-强化学习可以主动探索"><a href="#2-强化学习可以主动探索" class="headerlink" title="2.强化学习可以主动探索"></a>2.强化学习可以主动探索</h4><p>​    探索训练集之外的化学空间（怎么探索的？）</p><h4 id="3-直接优化"><a href="#3-直接优化" class="headerlink" title="3. 直接优化"></a>3. 直接优化</h4><p>​    VAE间接优化潜在嵌入空间的分子性质</p><p>​    直接优化分子图的分子性质（什么性质？）</p><h2 id="对抗训练"><a href="#对抗训练" class="headerlink" title="对抗训练"></a>对抗训练</h2><p>多属性预测困难</p><p>对抗性训练一个可学习的判别器</p><h2 id="分子生成环境"><a href="#分子生成环境" class="headerlink" title="分子生成环境"></a>分子生成环境</h2><p><strong>1. 状态空间</strong></p><p>分子图$ G(A,E,F)$,$A \in \{0,1\}^{n\times n}$是邻接矩阵，$F \in \mathbb{R}^{n \times d}$为每个节点的特征（假设有d个特征，这里是d个原子或子结构），$ E \in \{0,1\}^{b \times n \times n}$为边的种类与邻接矩阵。（A与E不重复吗？）</p><p><strong>2.动作空间</strong></p><p>在当前分子图上加上一堆待连的分子和子结构（脚手架），动作类似链路预测</p><p><strong>3.转移动态</strong></p><p>体现化学领域规则</p><p><strong>4.奖励设计</strong></p><p>中间奖励+最终奖励</p><p>中间奖励：有效性奖励+对抗奖励</p><p>最终奖励：化学领域奖励（QED）+对抗奖励</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>GCPN文章作者通过openai的gym搭建了一个强化学习分子生成环境</p><p>也就是gym_molecule/envs/molecule.py</p><p>其中定义了继承自gym.Env的分子环境 MoleculeEnv</p><p>MoleculeEnv中定义了一系列用于分子生成与观测的函数</p><h3 id="normalize-adj（adj）"><a href="#normalize-adj（adj）" class="headerlink" title="normalize_adj（adj）"></a>normalize_adj（adj）</h3><p>结点嵌入</p><p>$H^{(l+1)}=AGG(ReLU(\{\tilde{D_i}^{-\tfrac{1}{2}}\tilde E_{i}\tilde{D_i}^{-\tfrac{1}{2}}H^{(l)}W_{i}^{(l)}\},\forall i \in (1,…,b)))$</p><p>$\tilde{D_i}^{-\tfrac{1}{2}}\tilde E_{i}\tilde{D_i}^{-\tfrac{1}{2}}$类似一个归一化的拉普拉斯矩阵$L^{norm}$，其中引入自身度矩阵来解决自传递问题，对邻接矩阵通过度矩阵进行归一化，来防止度对结点权重的影响（也就是说10条边的结点比1条边的结点影响大的情况）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#adj为图邻接矩阵，相当于得到归一化拉普拉斯矩阵用于嵌入 adj第一维度是边类型，二三维度是邻接矩阵</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">normalize_adj</span>(<span class="params">self,adj</span>):</span></span><br><span class="line">       degrees = np.sum(adj,axis=<span class="number">2</span>)</span><br><span class="line">       <span class="comment"># print(&#x27;degrees&#x27;,degrees)</span></span><br><span class="line">       D = np.zeros((adj.shape[<span class="number">0</span>],adj.shape[<span class="number">1</span>],adj.shape[<span class="number">2</span>]))</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(D.shape[<span class="number">0</span>]):</span><br><span class="line">           D[i,:,:] = np.diag(np.power(degrees[i,:],<span class="number">-0.5</span>))</span><br><span class="line">       adj_normal = D@adj@D</span><br><span class="line">       adj_normal[np.isnan(adj_normal)]=<span class="number">0</span></span><br><span class="line">       <span class="keyword">return</span> adj_normal</span><br></pre></td></tr></table></figure><h2 id="step-action"><a href="#step-action" class="headerlink" title="step(action)"></a>step(action)</h2><p>action是一个四元组：两个端点、边类型预测、终止预测</p><p>step函数首先要执行动作：添加原子或添加化学键</p><p>生成终止条件有一个最小动作数的要求min_action</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> action[<span class="number">0</span>,<span class="number">3</span>]==<span class="number">0</span> <span class="keyword">or</span> self.counter &lt; self.min_action: <span class="comment"># not stop</span></span><br><span class="line">    stop = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> action[<span class="number">0</span>, <span class="number">1</span>] &gt;= total_atoms:</span><br><span class="line">        self._add_atom(action[<span class="number">0</span>, <span class="number">1</span>] - total_atoms)  <span class="comment"># add new node</span></span><br><span class="line">        action[<span class="number">0</span>, <span class="number">1</span>] = total_atoms  <span class="comment"># new node id</span></span><br><span class="line">        self._add_bond(action)  <span class="comment"># add new edge</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._add_bond(action)  <span class="comment"># add new edge</span></span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># stop</span></span><br><span class="line">    stop = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>其中还要完成奖励的设置</p><p>中间奖励+最终奖励</p><p>中间奖励： 主要是化合价的检测</p><ul><li><p>化合价正确，动作成功执行，奖励为正。</p></li><li><p>化合价错误或化学键已经存在，奖励为负</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### calculate intermediate rewards </span></span><br><span class="line"><span class="keyword">if</span> self.check_valency(): </span><br><span class="line">    <span class="keyword">if</span> self.mol.GetNumAtoms()+self.mol.GetNumBonds()-self.mol_old.GetNumAtoms()-self.mol_old.GetNumBonds()&gt;<span class="number">0</span>:</span><br><span class="line">        reward_step = self.reward_step_total/self.max_atom <span class="comment"># successfully add node/edge</span></span><br><span class="line">        self.smile_list.append(self.get_final_smiles())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        reward_step = -self.reward_step_total/self.max_atom <span class="comment"># edge exist</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    reward_step = -self.reward_step_total/self.max_atom  <span class="comment"># invalid action</span></span><br><span class="line">    self.mol = self.mol_old</span><br></pre></td></tr></table></figure><p>最终奖励：目标性质+化学有效性</p><p>化学有效性通过RDKit完成，先把分子对象Mol转化成SMILES形式，之后如果能成功转化回来，说明分子符合化学有效性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#检测化学有效性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_chemical_validity</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Checks the chemical validity of the mol object. Existing mol object is</span></span><br><span class="line"><span class="string">    not modified. Radicals pass this test.</span></span><br><span class="line"><span class="string">    :return: True if chemically valid, False otherwise</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    s = Chem.MolToSmiles(self.mol, isomericSmiles=<span class="literal">True</span>)</span><br><span class="line">    m = Chem.MolFromSmiles(s)  <span class="comment"># implicitly performs sanitization</span></span><br><span class="line">    <span class="keyword">if</span> m:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>反之，则分子不符合化学有效性，最终奖励中要施加惩罚</p><p>目标性质三种：</p><ul><li>药物相似性qed</li><li><p>油水分配系数LogP</p></li><li><p>综合可获得性Synthetic accessibility（SA）</p></li></ul><p>其中 qed与MolLogP都在rdkit.chem.descriptors中有对应的计算函数</p><p>SA通过第三方库sascorer.py中的calculateScore进行计算</p><h2 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h2><h3 id="计算结点嵌入"><a href="#计算结点嵌入" class="headerlink" title="计算结点嵌入"></a>计算结点嵌入</h3><p>l+1层的结点嵌入 $H^{(l+1)} \in \mathbb R^{(n+c)\times k}$ </p><p>n是图中结点数，c是脚手架结点数，k是嵌入后结点表示维数</p><p>$H^{(l+1)}=AGG(ReLU(\{\tilde{D_i}^{-\tfrac{1}{2}}\tilde E_{i}\tilde{D_i}^{-\tfrac{1}{2}}H^{(l)}W_{i}^{(l)}\},\forall i \in (1,…,b)))$</p><p>$E_i$是第i类边的邻接矩阵，$\tilde E_i = E_i + I$是考虑到自身结点信息的修改后的邻接矩阵，$\tilde D_i = \sum_{k}\tilde E_{ijk}$ 是修改后的度矩阵。</p><p>$\tilde{D_i}^{-\tfrac{1}{2}}\tilde E_{i}\tilde{D_i}^{-\tfrac{1}{2}}$类似一个归一化的拉普拉斯矩阵$L^{norm}$，其中引入自身度矩阵来解决自传递问题，对邻接矩阵通过度矩阵进行归一化，来防止度对结点权重的影响（也就是说10条边的结点比1条边的结点影响大的情况）</p><p>$L^{norm}H^{(l)}$相当于叠加结点自身与邻居结点的特征，通过多层$l$来利用更多层次邻居（邻居的邻居）的信息。</p><h3 id="动作预测"><a href="#动作预测" class="headerlink" title="动作预测"></a>动作预测</h3><p>链路预测</p><p>动作：四个组成 两个端点、边类型预测、终止预测</p><p>$ a_t = CONCAT(a_{first},a_{second},a_{edge},a_{stop})$</p><p>$f_{first}(s_{t}) = SOFTMAX(m_f(X)),\quad \quad \quad a_{first} \sim f_{first}(s_t) \in \{0,1\}^{n}$</p><p>$f_{second}(s_{t}) = SOFTMAX(m_s(X_{a_{first}},X)),\quad \quad a_{second} \sim f_{second}(s_t) \in \{0,1\}^{n+c}$</p><p>$f_{edge}(s_{t}) = SOFTMAX(m_e(X_{a_{first}},X_{a_{second}})),\quad \quad a_{edge} \sim f_{edge}(s_t) \in \{0,1\}^{b}$</p><p>$f_{stop}(s_{t}) = SOFTMAX(m_t(AGG(X))),\quad \quad a_{stop} \sim f_{stop}(s_t) \in \{0,1\}$</p><h3 id="ppo？"><a href="#ppo？" class="headerlink" title="ppo？"></a>ppo？</h3><h4 id="策略梯度方法推导"><a href="#策略梯度方法推导" class="headerlink" title="策略梯度方法推导"></a>策略梯度方法推导</h4><p>轨迹$\tau = (s_{0},a_{0},…,s_{h},a_{h})$</p><p>目标：找到最优神经网络参数$\theta^{*}$最大化收益关于轨迹分布的期望</p><p>$\theta^{*}=\mathop{\arg\max}\limits_{\theta} \mathbb{E}_{\tau \sim p_{\theta}(\tau)}\bigg[\sum\limits_{t}r(s_{t},a_{t})\bigg]$</p><p>目标函数 $J(\theta)=\mathbb{E}_{\tau\sim p_{\theta}(\tau)}\bigg[\sum\limits_{t}r(s_t,a_t)\bigg]$</p><p>定义轨迹收益$r(\tau)=\sum\limits_t r(s_t,a_t)$，目标函数变成$J(\theta)=\mathbb{E}_{\tau\sim p_{\theta}(\tau)}[r(\tau)]$</p><p>假设$\tau$的分布函数$p_{\theta}(\tau)$是可微的，拆开期望： $J(\theta)=\int p_{\theta}(\tau)r(\tau)\,{\rm d}\tau$</p><p>对两边求梯度：$\nabla_{\theta} J(\theta)=\int \nabla_{\theta} p_{\theta}(\tau)r(\tau)\,{\rm d}\tau$</p><p>其中等式$\nabla_{\theta}p_{\theta}(\tau) = p_{\theta}(\tau)\nabla_\theta logp_\theta(\tau)$成立</p><p>因此</p><script type="math/tex; mode=display">\begin{aligned} \nabla_{\theta} J(\theta)&=\int p_{\theta}(\tau)\nabla_\theta logp_\theta(\tau)r(\tau)\,{\rm d}\tau\\&= \mathbb{E}_{\tau\sim p_\theta(\tau)}\bigg[\nabla_\theta logp_\theta(\tau)r(\tau)\bigg]\end{aligned}</script><p>其中$p_{\theta}(\tau)=p(s_1)\prod\limits_{t=1}^{T}\pi_{\theta}(a_t,s_t)p(s_{t+1})$</p><p>则$\nabla_\theta logp_\theta(\tau) = \nabla_\theta \sum \limits_{t=1}^{T}log\pi_{\theta}(a_t,s_t)$</p><p>$\nabla_{\theta} J(\theta) = \mathbb{E}_{\tau\sim p_\theta(\tau)}\bigg[\bigg( \sum \limits_{t=1}^{T}\nabla_\theta log\pi_{\theta}(a_t,s_t)\bigg)\bigg(\sum \limits_{t=1}^{T}r(s_t,a_t)\bigg)\bigg]$</p><p>实际抽样时用平均来进行估算</p><p>$\nabla_{\theta} J(\theta) \approx \frac{1}{N} \sum \limits_{i=1}^{N} \bigg[\bigg( \sum \limits_{t=1}^{T}\nabla_\theta log\pi_{\theta}(a_{i,t},s_{i,t})\bigg)\bigg(\sum \limits_{t=1}^{T}r(s_{i,t},a_{i,t})\bigg)\bigg]$</p><p>之后用 $\theta \gets \theta + \nabla_{\theta} J(\theta)$更新参数$\theta$</p><h5 id="解决高方差问题"><a href="#解决高方差问题" class="headerlink" title="解决高方差问题"></a>解决高方差问题</h5><h6 id="改变因果关系"><a href="#改变因果关系" class="headerlink" title="改变因果关系"></a>改变因果关系</h6><p>当前时间策略只能影响之后的奖励</p><p>$\nabla_{\theta} J(\theta) \approx \frac{1}{N} \sum \limits_{i=1}^{N}\sum \limits_{t=1}^{T} \bigg[\bigg( \nabla_\theta log\pi_{\theta}(a_{i,t},s_{i,t})\bigg)\bigg(\sum \limits_{t’=t}^{T}r(s_{i,t’},a_{i,t’})\bigg)\bigg]$</p><h6 id="引入基线"><a href="#引入基线" class="headerlink" title="引入基线"></a>引入基线</h6><p>$\nabla_{\theta} J(\theta)= \mathbb{E}_{\tau\sim p_\theta(\tau)}\bigg[\nabla_\theta logp_\theta(\tau)(r(\tau)-b)\bigg]$</p><p>eg： $b_t = \frac{1}{N} \sum \limits_{i} Q^\pi(s_{i,t},a_{i,t})$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Graph Convolutional Policy Network for Goal-Directed Molecular Graph Generation》&lt;/p&gt;
&lt;h2 id=&quot;GCPN&quot;&gt;&lt;a href=&quot;#GCPN&quot; class=&quot;headerlink&quot; title=&quot;GCPN&quot;&gt;&lt;/a&gt;GCPN&lt;/h2&gt;&lt;h3 id=&quot;应用目标导向&quot;&gt;&lt;a href=&quot;#应用目标导向&quot; class=&quot;headerlink&quot; title=&quot;应用目标导向&quot;&gt;&lt;/a&gt;应用目标导向&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;分子空间大：$10^{60}$&lt;/li&gt;
&lt;li&gt;化学空间离散，分子性质对微小的结构改变也很敏感&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;GCPN-1&quot;&gt;&lt;a href=&quot;#GCPN-1&quot; class=&quot;headerlink&quot; title=&quot;GCPN&quot;&gt;&lt;/a&gt;GCPN&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;图卷积策略网络，引导生成特定期望目标同时用基本化学规则限制输出空间&lt;/li&gt;
&lt;li&gt;图表示+强化学习+对抗训练&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://www.aoshuqiu.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://www.aoshuqiu.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="强化学习" scheme="https://www.aoshuqiu.top/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="图表示" scheme="https://www.aoshuqiu.top/tags/%E5%9B%BE%E8%A1%A8%E7%A4%BA/"/>
    
  </entry>
  
  <entry>
    <title>策略梯度方法推导</title>
    <link href="https://www.aoshuqiu.top/2021/01/13/policy%20gradient/"/>
    <id>https://www.aoshuqiu.top/2021/01/13/policy%20gradient/</id>
    <published>2021-01-13T06:20:10.000Z</published>
    <updated>2021-01-18T09:37:16.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="策略梯度方法推导"><a href="#策略梯度方法推导" class="headerlink" title="策略梯度方法推导"></a>策略梯度方法推导</h2><p>轨迹$\tau = (s_{0},a_{0},…,s_{h},a_{h})$</p><p><strong>目标：找到最优神经网络参数$\theta^{*}$最大化收益关于轨迹分布的期望</strong></p><p>$\theta^{*}=\mathop{\arg\max}\limits_{\theta} \mathbb{E}_{\tau \sim p_{\theta}(\tau)}\bigg[\sum\limits_{t}r(s_{t},a_{t})\bigg]$</p><p>目标函数 $J(\theta)=\mathbb{E}_{\tau\sim p_{\theta}(\tau)}\bigg[\sum\limits_{t}r(s_t,a_t)\bigg]$</p><p>定义轨迹收益$r(\tau)=\sum\limits_t r(s_t,a_t)$，目标函数变成$J(\theta)=\mathbb{E}_{\tau\sim p_{\theta}(\tau)}[r(\tau)]$</p><a id="more"></a><p>假设$\tau$的分布函数$p_{\theta}(\tau)$是可微的，拆开期望： $J(\theta)=\int p_{\theta}(\tau)r(\tau)\,{\rm d}\tau$</p><p>对两边求梯度：$\nabla_{\theta} J(\theta)=\int \nabla_{\theta} p_{\theta}(\tau)r(\tau)\,{\rm d}\tau$</p><p>其中等式$\nabla_{\theta}p_{\theta}(\tau) = p_{\theta}(\tau)\nabla_\theta logp_\theta(\tau)$成立</p><p>因此</p><script type="math/tex; mode=display">\begin{align} \nabla_{\theta} J(\theta)&=\int p_{\theta}(\tau)\nabla_\theta logp_\theta(\tau)r(\tau)\,{\rm d}\tau\\&= \mathbb{E}_{\tau\sim p_\theta(\tau)}\bigg[\nabla_\theta logp_\theta(\tau)r(\tau)\bigg]\end{align}</script><p>其中$p_{\theta}(\tau)=p(s_1)\prod\limits_{t=1}^{T}\pi_{\theta}(a_t,s_t)p(s_{t+1})$</p><p>则$\nabla_\theta logp_\theta(\tau) = \nabla_\theta \sum \limits_{t=1}^{T}log\pi_{\theta}(a_t,s_t)$</p><p>$\nabla_{\theta} J(\theta) = \mathbb{E}_{\tau\sim p_\theta(\tau)}\bigg[\bigg( \sum \limits_{t=1}^{T}\nabla_\theta log\pi_{\theta}(a_t,s_t)\bigg)\bigg(\sum \limits_{t=1}^{T}r(s_t,a_t)\bigg)\bigg]$</p><p>实际抽样时用平均来进行估算</p><p>$\nabla_{\theta} J(\theta) \approx \frac{1}{N} \sum \limits_{i=1}^{N} \bigg[\bigg( \sum \limits_{t=1}^{T}\nabla_\theta log\pi_{\theta}(a_{i,t},s_{i,t})\bigg)\bigg(\sum \limits_{t=1}^{T}r(s_{i,t},a_{i,t})\bigg)\bigg]$</p><p>之后用 $\theta \gets \theta + \nabla_{\theta} J(\theta)$更新参数$\theta$</p><h2 id="解决高方差问题"><a href="#解决高方差问题" class="headerlink" title="解决高方差问题"></a>解决高方差问题</h2><h3 id="改变因果关系"><a href="#改变因果关系" class="headerlink" title="改变因果关系"></a>改变因果关系</h3><p>当前时间策略只能影响之后的奖励</p><p>$\nabla_{\theta} J(\theta) \approx \frac{1}{N} \sum \limits_{i=1}^{N}\sum \limits_{t=1}^{T} \bigg[\bigg( \nabla_\theta log\pi_{\theta}(a_{i,t},s_{i,t})\bigg)\bigg(\sum \limits_{t’=t}^{T}r(s_{i,t’},a_{i,t’})\bigg)\bigg]$</p><h3 id="引入基线"><a href="#引入基线" class="headerlink" title="引入基线"></a>引入基线</h3><p>$\nabla_{\theta} J(\theta)= \mathbb{E}_{\tau\sim p_\theta(\tau)}\bigg[\nabla_\theta logp_\theta(\tau)(r(\tau)-b)\bigg]$</p><p>eg： $b_t = \frac{1}{N} \sum \limits_{i} Q^\pi(s_{i,t},a_{i,t})$</p><h2 id="解决样本效率问题"><a href="#解决样本效率问题" class="headerlink" title="解决样本效率问题"></a>解决样本效率问题</h2><p>问题：<strong>每次更新参数$\theta$ 都要重新进行采样，数据利用率低，会影响到收敛的速度</strong>  怎么利用之前的样本？</p><h3 id="重要性采样"><a href="#重要性采样" class="headerlink" title="重要性采样"></a>重要性采样</h3><p>原理：</p><p>$\mathbb{E}_{x \sim p(x)}[f(x)] = \int p(x)f(x)\, {\rm d}x = \int q(x)\frac{p(x)}{q(x)}f(x)\,{\rm d}x = \mathbb{E}_{x \sim q(x)}[\frac{p(x)}{q(x)}f(x)] $</p><p>从q(x)中采样来替代从p(x)中采样</p><p><strong>修改：</strong></p><p>应用到目标函数</p><p>$ J(\theta) = \mathbb{E}_{\tau \sim p_{\theta}(\tau)}[r(\tau)] = \mathbb{E}_{\tau \sim p_{\theta^{old}}(\tau)}\bigg[\frac{p_{\theta}(\tau)}{p_{\theta^{old}}(\tau)}\bigg]$</p><p>比值项</p><p>$\frac{p_{\theta}(\tau)}{p_{\theta^{old}}(\tau)} = \frac{p(s_{1})\prod \limits_{t=1}^{T}\pi_{\theta}(a_{t}|s_{t})p(s_{t+1}|s_{t},a_{t})}{p(s_{1})\prod \limits_{t=1}^{T}\pi_{\theta^{old}}(a_{t}|s_{t})p(s_{t+1}|s_{t},a_{t})} = \frac{\prod \limits_{t=1}^{T}\pi_{\theta}(a_{t}|s_{t})}{\prod \limits_{t=1}^{T}\pi_{\theta^{old}}(a_{t}|s_{t})}$</p><p>得出</p><p>$\nabla_{\theta}J(\theta) = \mathbb{E}_{\tau \sim p_{\theta}(\tau)}\bigg[\sum \limits_{t=1}^{T} \nabla_{\theta} log \pi_{\theta}(a_t|s_t)\bigg(\prod \limits_{t’=1}^{t} \frac{\pi_{\theta}(a_{t’}|s_{t’})}{\pi_{\theta^{old}}(a_{t’}|s_{t’})}\bigg)\bigg(\sum \limits_{t’ =t}^{T}r(s_{t’},a_{t’})-b\bigg)\bigg]$</p><p>连乘可能趋于0’</p><p>修改</p><p><img src="/2021/01/13/policy%20gradient/image-20210101221252416.png" alt="image-20210101221252416"></p><p>最终</p><p><img src="/2021/01/13/policy%20gradient/image-20210101220947618.png" alt="image-20210101220947618"></p><p><img src="/2021/01/13/policy%20gradient/image-20210101221325924.png" alt="image-20210101221325924"></p><p>近似1</p><p>可以拿出去加基线</p><p>新参数可以利用旧采样，一段时间后再重新采样？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;策略梯度方法推导&quot;&gt;&lt;a href=&quot;#策略梯度方法推导&quot; class=&quot;headerlink&quot; title=&quot;策略梯度方法推导&quot;&gt;&lt;/a&gt;策略梯度方法推导&lt;/h2&gt;&lt;p&gt;轨迹$\tau = (s_{0},a_{0},…,s_{h},a_{h})$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标：找到最优神经网络参数$\theta^{*}$最大化收益关于轨迹分布的期望&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$\theta^{*}=\mathop{\arg\max}\limits_{\theta} \mathbb{E}_{\tau \sim p_{\theta}(\tau)}\bigg[\sum\limits_{t}r(s_{t},a_{t})\bigg]$&lt;/p&gt;
&lt;p&gt;目标函数 $J(\theta)=\mathbb{E}_{\tau\sim p_{\theta}(\tau)}\bigg[\sum\limits_{t}r(s_t,a_t)\bigg]$&lt;/p&gt;
&lt;p&gt;定义轨迹收益$r(\tau)=\sum\limits_t r(s_t,a_t)$，目标函数变成$J(\theta)=\mathbb{E}_{\tau\sim p_{\theta}(\tau)}[r(\tau)]$&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://www.aoshuqiu.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://www.aoshuqiu.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="强化学习" scheme="https://www.aoshuqiu.top/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历-Morris中序遍历</title>
    <link href="https://www.aoshuqiu.top/2020/08/08/leetcode-99/"/>
    <id>https://www.aoshuqiu.top/2020/08/08/leetcode-99/</id>
    <published>2020-08-08T09:42:36.000Z</published>
    <updated>2020-08-08T13:08:55.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Morris中序遍历"><a href="#Morris中序遍历" class="headerlink" title="Morris中序遍历"></a>Morris中序遍历</h2><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>二叉树的中序(inorder)遍历，也就是二叉树最平常的遍历算法。对于树中每个节点，递归遍历左子树，之后遍历本节点，最后遍历右子树。其中分为迭代与递归两种等价写法，迭代实现需要手动维护一个节点栈。</p><p>这个遍历算法的时间复杂度为$O(N)$，其中N为二叉树的节点数，空间复杂度为$O(N)$(若用数组存储遍历序列),或$O(H)$,$H$为二叉树高度（用迭代实现，栈中存储结点）。</p><p>然而，存在一个<strong>常数空间</strong>算法来解决这个问题：</p><h3 id="Morris-遍历"><a href="#Morris-遍历" class="headerlink" title="Morris 遍历"></a>Morris 遍历</h3><a id="more"></a><p>Morris遍历算法只需要维护一个节点$pred$，它代表最终遍历序列中的前序节点。</p><p>算法的整体步骤如下：（假设当前遍历到的节点为$x$）</p><ul><li>若$x$无左孩子，则可以将$x$输出，即$pred = x$,之后遍历$x$的右孩子。</li><li>若$x$有左孩子，则先寻找x左子树上的最右节点（也就是$x$在中序遍历中的前序节点），记为$predecessor$。其中：<ul><li>若$predecessor$的右孩子为空，则将它的右孩子指向$x$,之后遍历$x$的左孩子。</li><li>若$predecessor$的右孩子不为空，它只能为$x$，则说明此时是第二次遍历节点$x$（即之前进行过上一步）, 因此将$predecessor$的右孩子置为空，输出$x$即$pred=x$，之后遍历$x$的右孩子</li></ul></li><li>重复上述操作，直至访问完整棵树</li></ul><p><strong>算法理解：</strong></p><p>改变$predecessor$的右孩子，使其指向$x$，便于遍历左子树后能遍历回节点$x$。每次条件判断后只遍历一个子节点，相当于将树形结构变成了线性结构，通过遍历每个节点2次来降低算法的空间复杂度。</p><p>时间复杂度：$O(2N) = O(N)$</p><p>空间复杂度：$O(1)$</p><h3 id="leetcode-99-恢复二叉搜索树"><a href="#leetcode-99-恢复二叉搜索树" class="headerlink" title="leetcode 99 恢复二叉搜索树"></a>leetcode 99 恢复二叉搜索树</h3><p>二叉搜索树中的两个节点被错误地交换。</p><p>请在不改变其结构的情况下，恢复这棵树。</p><p>示例 1:</p><p>输入: [1,3,null,null,2]</p><p>   1<br>  /<br> 3<br>  \<br>   2</p><p>输出: [3,1,null,null,2]</p><p>   3<br>  /<br> 1<br>  \<br>   2</p><p>示例 2:</p><p>输入: [3,1,4,null,null,2]</p><p>  3<br> / \<br>1   4<br>   /<br>  2</p><p>输出: [2,1,4,null,null,3]</p><p>  2<br> / \<br>1   4<br>   /<br>  3</p><p>进阶:</p><ul><li>使用 O(n) 空间复杂度的解法很容易实现。</li><li>你能想出一个只使用常数空间的解决方案吗？</li></ul><p>写的时候有点着急，代码有点乱</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        wrongNode=[]</span><br><span class="line">        pred = <span class="literal">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">morrisInorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> pred</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                predecessor = root.left</span><br><span class="line">                <span class="keyword">while</span> predecessor.right <span class="keyword">and</span> predecessor.right!=root: predecessor = predecessor.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> predecessor.right:</span><br><span class="line">                    predecessor.right = root</span><br><span class="line">                    morrisInorder(root.left)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> pred <span class="keyword">and</span> pred.val &gt; root.val:</span><br><span class="line">                        wrongNode.append([pred,root])</span><br><span class="line">                    predecessor.right = <span class="literal">None</span></span><br><span class="line">                    pred=root</span><br><span class="line">                    <span class="keyword">if</span> root.right:</span><br><span class="line">                        morrisInorder(root.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> pred <span class="keyword">and</span> pred.val &gt; root.val:</span><br><span class="line">                    wrongNode.append([pred,root])</span><br><span class="line">                pred=root</span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    morrisInorder(root.right)    </span><br><span class="line">        morrisInorder(root)</span><br><span class="line">        <span class="keyword">if</span> len(wrongNode)==<span class="number">1</span>:</span><br><span class="line">            temp = wrongNode[<span class="number">0</span>][<span class="number">1</span>].val</span><br><span class="line">            wrongNode[<span class="number">0</span>][<span class="number">1</span>].val = wrongNode[<span class="number">0</span>][<span class="number">0</span>].val</span><br><span class="line">            wrongNode[<span class="number">0</span>][<span class="number">0</span>].val = temp</span><br><span class="line">        <span class="keyword">if</span> len(wrongNode)==<span class="number">2</span>:</span><br><span class="line">            temp = wrongNode[<span class="number">0</span>][<span class="number">0</span>].val</span><br><span class="line">            wrongNode[<span class="number">0</span>][<span class="number">0</span>].val = wrongNode[<span class="number">1</span>][<span class="number">1</span>].val</span><br><span class="line">            wrongNode[<span class="number">1</span>][<span class="number">1</span>].val = temp</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Morris中序遍历&quot;&gt;&lt;a href=&quot;#Morris中序遍历&quot; class=&quot;headerlink&quot; title=&quot;Morris中序遍历&quot;&gt;&lt;/a&gt;Morris中序遍历&lt;/h2&gt;&lt;h3 id=&quot;中序遍历&quot;&gt;&lt;a href=&quot;#中序遍历&quot; class=&quot;headerlink&quot; title=&quot;中序遍历&quot;&gt;&lt;/a&gt;中序遍历&lt;/h3&gt;&lt;p&gt;二叉树的中序(inorder)遍历，也就是二叉树最平常的遍历算法。对于树中每个节点，递归遍历左子树，之后遍历本节点，最后遍历右子树。其中分为迭代与递归两种等价写法，迭代实现需要手动维护一个节点栈。&lt;/p&gt;
&lt;p&gt;这个遍历算法的时间复杂度为$O(N)$，其中N为二叉树的节点数，空间复杂度为$O(N)$(若用数组存储遍历序列),或$O(H)$,$H$为二叉树高度（用迭代实现，栈中存储结点）。&lt;/p&gt;
&lt;p&gt;然而，存在一个&lt;strong&gt;常数空间&lt;/strong&gt;算法来解决这个问题：&lt;/p&gt;
&lt;h3 id=&quot;Morris-遍历&quot;&gt;&lt;a href=&quot;#Morris-遍历&quot; class=&quot;headerlink&quot; title=&quot;Morris 遍历&quot;&gt;&lt;/a&gt;Morris 遍历&lt;/h3&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://www.aoshuqiu.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="leetcode" scheme="https://www.aoshuqiu.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.aoshuqiu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://www.aoshuqiu.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 336 回文对</title>
    <link href="https://www.aoshuqiu.top/2020/08/06/leetcode-336/"/>
    <id>https://www.aoshuqiu.top/2020/08/06/leetcode-336/</id>
    <published>2020-08-06T12:26:17.000Z</published>
    <updated>2020-08-08T13:09:03.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回文对问题"><a href="#回文对问题" class="headerlink" title="回文对问题"></a>回文对问题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><h4 id><a href="#" class="headerlink" title=" "></a> </h4><p>给定一组 <strong>互不相同</strong> 的单词， 找出所有<strong>不同</strong> 的索引对<code>(i, j)</code>，使得列表中的两个单词， <code>words[i] + words[j]</code> ，可拼接成回文串。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：[&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;]</span><br><span class="line">&gt;输出：[[0,1],[1,0],[3,2],[2,4]] </span><br><span class="line">&gt;解释：可拼接成的回文串为 [&quot;dcbaabcd&quot;,&quot;abcddcba&quot;,&quot;slls&quot;,&quot;llssssll&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：[&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;]</span><br><span class="line">&gt;输出：[[0,1],[1,0]] </span><br><span class="line">&gt;解释：可拼接成的回文串为 [&quot;battab&quot;,&quot;tabbat&quot;]</span><br></pre></td></tr></table></figure></blockquote><a id="more"></a><h2 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h2><p>两重循环枚举字符串组合，判断是否能构成回文串。时间复杂度为 $O(n^2\times m)$ ，其中n为字符串数量，m为字符串平均长度。测试用例中的字符串数目都很多，因此这个时间复杂度不能满足题目要求。</p><h2 id="枚举前缀与后缀"><a href="#枚举前缀与后缀" class="headerlink" title="枚举前缀与后缀"></a>枚举前缀与后缀</h2><p><strong>思路及算法 </strong></p><p>如果两个字符串$ s_1 $和$s_2$，$s_1 + s_2$是一个回文串，那么对于其中较长的字符串$ s$可以分为两个部分，一部分是一个回文串，另一部分是较短的字符串的翻转。其中空串也为回文串。</p><p>也就是说，枚举每一个字符串$k$令其为$s_1$,$s_2$中较长的那一个，枚举字符串k的包括空串的每一个前缀与后缀，判断其是否为回文串，如果是回文串，就判断剩余部分的翻转是否在字符串序列中。</p><p>其中字符串搜索有两种方式：字典树与哈希表</p><p><strong>字典树 </strong></p><p>一个树型结构，每个字符输入对应一个有向边，每个节点对应一个字符串。根节点为空串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#树的节点，ch代表节点接收一个字符的出边，值为指向的节点序号</span></span><br><span class="line"><span class="comment">#flag: 节点代表的字符串的索引</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.ch = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        self.flag = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">palindromePairs</span>(<span class="params">self, words: List[str]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment">#初始化字典树</span></span><br><span class="line">        tree = [Node()]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#s:要插入的字符串</span></span><br><span class="line">        <span class="comment">#index: s对应的索引</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">s: str, index: int</span>):</span></span><br><span class="line">            length = len(s)</span><br><span class="line">            add = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">                x = ord(s[i]) - ord(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">                <span class="comment">#不存在这个字符的子节点:新建一个节点并指向它</span></span><br><span class="line">                <span class="keyword">if</span> tree[add].ch[x] == <span class="number">0</span>:</span><br><span class="line">                    tree.append(Node())</span><br><span class="line">                    tree[add].ch[x] = len(tree) - <span class="number">1</span></span><br><span class="line">                <span class="comment">#移动到下一个节点继续搜寻</span></span><br><span class="line">                add = tree[add].ch[x]</span><br><span class="line">            tree[add].flag = index</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#s:要寻找的字符串</span></span><br><span class="line">        <span class="comment">#left:s最左字符索引</span></span><br><span class="line">        <span class="comment">#right:s最右字符索引</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findWord</span>(<span class="params">s: str, left: int, right: int</span>) -&gt; int:</span></span><br><span class="line">            add = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(right, left - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">                x = ord(s[i]) - ord(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> tree[add].ch[x] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">                add = tree[add].ch[x]</span><br><span class="line">            <span class="keyword">return</span> tree[add].flag</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">s: str, left: int, right: int</span>) -&gt; bool:</span></span><br><span class="line">            length = right - left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> length &lt; <span class="number">0</span> <span class="keyword">or</span> all(s[left + i] == s[right - i] <span class="keyword">for</span> i <span class="keyword">in</span> range(length // <span class="number">2</span>))</span><br><span class="line">        </span><br><span class="line">        n = len(words)</span><br><span class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(words):</span><br><span class="line">            insert(word, i)</span><br><span class="line">        </span><br><span class="line">        ret = list()</span><br><span class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(words):</span><br><span class="line">            m = len(word)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> isPalindrome(word, j, m - <span class="number">1</span>):</span><br><span class="line">                    leftId = findWord(word, <span class="number">0</span>, j - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> leftId != <span class="number">-1</span> <span class="keyword">and</span> leftId != i:</span><br><span class="line">                        ret.append([i, leftId])</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">and</span> isPalindrome(word, <span class="number">0</span>, j - <span class="number">1</span>):</span><br><span class="line">                    rightId = findWord(word, j, m - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> rightId != <span class="number">-1</span> <span class="keyword">and</span> rightId != i:</span><br><span class="line">                        ret.append([rightId, i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p><strong>哈希表 </strong></p><p>python中通过dict类型作为哈希表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">palindromePairs</span>(<span class="params">self, words: List[str]</span>) -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findWord</span>(<span class="params">s: str, left: int, right: int</span>) -&gt; int:</span></span><br><span class="line">            <span class="keyword">return</span> indices.get(s[left:right+<span class="number">1</span>], <span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">s: str, left: int, right: int</span>) -&gt; bool:</span></span><br><span class="line">            <span class="keyword">return</span> (sub := s[left:right+<span class="number">1</span>]) == sub[::<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        n = len(words)</span><br><span class="line">        indices = &#123;word[::<span class="number">-1</span>]: i <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(words)&#125;</span><br><span class="line">        </span><br><span class="line">        ret = list()</span><br><span class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(words):</span><br><span class="line">            m = len(word)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> isPalindrome(word, j, m - <span class="number">1</span>):</span><br><span class="line">                    leftId = findWord(word, <span class="number">0</span>, j - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> leftId != <span class="number">-1</span> <span class="keyword">and</span> leftId != i:</span><br><span class="line">                        ret.append([i, leftId])</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">and</span> isPalindrome(word, <span class="number">0</span>, j - <span class="number">1</span>):</span><br><span class="line">                    rightId = findWord(word, j, m - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> rightId != <span class="number">-1</span> <span class="keyword">and</span> rightId != i:</span><br><span class="line">                        ret.append([rightId, i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度为$O(n \times m^2)$，其中需要$O(m^2)$来判断一个字符串所有的前缀与后缀是否是回文串，并且$O(m^2)$地判断剩余部分是否在字符串序列中出现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;回文对问题&quot;&gt;&lt;a href=&quot;#回文对问题&quot; class=&quot;headerlink&quot; title=&quot;回文对问题&quot;&gt;&lt;/a&gt;回文对问题&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;h4 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h4&gt;&lt;p&gt;给定一组 &lt;strong&gt;互不相同&lt;/strong&gt; 的单词， 找出所有&lt;strong&gt;不同&lt;/strong&gt; 的索引对&lt;code&gt;(i, j)&lt;/code&gt;，使得列表中的两个单词， &lt;code&gt;words[i] + words[j]&lt;/code&gt; ，可拼接成回文串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;输入：[&amp;quot;abcd&amp;quot;,&amp;quot;dcba&amp;quot;,&amp;quot;lls&amp;quot;,&amp;quot;s&amp;quot;,&amp;quot;sssll&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;输出：[[0,1],[1,0],[3,2],[2,4]] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;解释：可拼接成的回文串为 [&amp;quot;dcbaabcd&amp;quot;,&amp;quot;abcddcba&amp;quot;,&amp;quot;slls&amp;quot;,&amp;quot;llssssll&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;输入：[&amp;quot;bat&amp;quot;,&amp;quot;tab&amp;quot;,&amp;quot;cat&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;输出：[[0,1],[1,0]] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;解释：可拼接成的回文串为 [&amp;quot;battab&amp;quot;,&amp;quot;tabbat&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://www.aoshuqiu.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="leetcode" scheme="https://www.aoshuqiu.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.aoshuqiu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>课程表问题</title>
    <link href="https://www.aoshuqiu.top/2020/08/06/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
    <id>https://www.aoshuqiu.top/2020/08/06/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%B3%95/</id>
    <published>2020-08-06T03:36:47.000Z</published>
    <updated>2020-08-06T05:16:25.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-207-课程表"><a href="#leetcode-207-课程表" class="headerlink" title="leetcode 207 课程表"></a>leetcode 207 课程表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p><p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p><a id="more"></a><p>示例 1:</p><p>输入: 2, [[1,0]]<br>输出: true<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</p><p>示例 2:</p><p>输入: 2, [[1,0],[0,1]]<br>输出: false<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</p><p>提示：</p><pre><code>1. 输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。2. 你可以假定输入的先决条件中没有重复的边。3. 1 &lt;= numCourses &lt;= 10^5</code></pre></blockquote><p>首先分析题目，先决条件就是要想学0，必须先学1，因此可以用一个有向图来表示课程关系。若此有向图为无环有向图，则存在一个拓扑序列满足这个先决条件。</p><h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>一开始想用邻接矩阵与numpy库中的点乘来得到图的到达节点矩阵，但是dot()函数花费太大了，导致时间过长。</p><h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>对图中的每个节点，用一个单向链表列出从该节点出发的所有弧，链表中每个单元对应一条出弧，单元中还可以包含弧上的权作为数据域。</p><p><img src="/2020/08/06/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%B3%95/2011050620362625.png" alt="img"></p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>对于一个节点 u，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 u 的时候，u 本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 u 出发通过一条有向边可以到达的所有节点。</p><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><ul><li><p>「未搜索」：我们还没有搜索到这个节点；</p></li><li><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p></li><li><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p></li></ul><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><p>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</p><ul><li><p>如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</p></li><li><p>如果 v 为「搜索中」，说明u这个点有一条到本次搜索上层点v的弧，则u，v互相都可以到达，因此该图存在弧。</p></li><li><p>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u,v) 之前的拓扑关系，以及不用进行任何操作。</p></li><li><p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</p></li></ul><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span>(<span class="params">self, numCourses: int, prerequisites: List[List[int]]</span>) -&gt; bool:</span></span><br><span class="line">        edges = collections.defaultdict(list)</span><br><span class="line">        visited = [<span class="number">0</span>] * numCourses</span><br><span class="line">        result = list()</span><br><span class="line">        valid = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> prerequisites:</span><br><span class="line">            edges[info[<span class="number">1</span>]].append(info[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">u: int</span>):</span></span><br><span class="line">            <span class="keyword">nonlocal</span> valid</span><br><span class="line">            visited[u] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> edges[u]:</span><br><span class="line">                <span class="keyword">if</span> visited[v] == <span class="number">0</span>:</span><br><span class="line">                    dfs(v)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> valid:</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">elif</span> visited[v] == <span class="number">1</span>:</span><br><span class="line">                    valid = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            visited[u] = <span class="number">2</span></span><br><span class="line">            result.append(u)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            <span class="keyword">if</span> valid <span class="keyword">and</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">                dfs(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> valid</span><br></pre></td></tr></table></figure><h3 id="入度表BFS"><a href="#入度表BFS" class="headerlink" title="入度表BFS"></a>入度表BFS</h3><p>我们使用一个队列来进行广度优先搜索。初始时，所有入度为 000 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，我们取出队首的节点 u：</p><ul><li><p>我们将 u放入答案中；</p></li><li><p>我们移除 u 的所有出边，也就是将 u的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。</p></li></ul><p>在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span>(<span class="params">self, numCourses: int, prerequisites: List[List[int]]</span>) -&gt; bool:</span></span><br><span class="line">        adjacency = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        indegrees = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="keyword">for</span> cur,pre <span class="keyword">in</span> prerequisites:</span><br><span class="line">            indegrees[cur] += <span class="number">1</span></span><br><span class="line">            adjacency[pre].append(cur)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(indegrees)):</span><br><span class="line">            <span class="keyword">if</span> indegrees[i] ==<span class="number">0</span>:</span><br><span class="line">                queue.append(i)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            pre = queue.popleft()</span><br><span class="line">            numCourses -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> cur <span class="keyword">in</span> adjacency[pre]:</span><br><span class="line">                indegrees[cur] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> indegrees[cur] == <span class="number">0</span>: queue.append(cur)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> numCourses</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-207-课程表&quot;&gt;&lt;a href=&quot;#leetcode-207-课程表&quot; class=&quot;headerlink&quot; title=&quot;leetcode 207 课程表&quot;&gt;&lt;/a&gt;leetcode 207 课程表&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。&lt;/p&gt;
&lt;p&gt;在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]&lt;/p&gt;
&lt;p&gt;给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://www.aoshuqiu.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="leetcode" scheme="https://www.aoshuqiu.top/tags/leetcode/"/>
    
      <category term="算法" scheme="https://www.aoshuqiu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="https://www.aoshuqiu.top/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统大作业——Hello的一生</title>
    <link href="https://www.aoshuqiu.top/2020/08/04/cs/"/>
    <id>https://www.aoshuqiu.top/2020/08/04/cs/</id>
    <published>2020-08-04T04:42:24.000Z</published>
    <updated>2020-08-04T07:22:53.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机系统大作业——Hello的一生"><a href="#计算机系统大作业——Hello的一生" class="headerlink" title="计算机系统大作业——Hello的一生"></a>计算机系统大作业——Hello的一生</h1><p><strong>摘 要</strong></p><p>  本文以hello.c为例，探寻程序由代码一步步经过预处理、编译、链接、之后成为进程，并被系统进行管理的过程。从而窥探程序由出生到死去的过程中，计算机系统各个部分是如何协调工作的，随着hello.c的一步步变化逐渐理解机器的运行机制。</p><p><strong>关键词：</strong>计算机系统；P2P；程序运行全过程；             </p><a id="more"></a><h1 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h1><h2 id="1-1-Hello简介"><a href="#1-1-Hello简介" class="headerlink" title="1.1 Hello简介"></a>1.1 Hello简介</h2><p>hello.c先经过预处理变为hello.i，后经过编译变为汇编文件hello.s，再经过汇编变为可重定向目标文件hello.o，最后经过链接变为可执行目标文件hello.out</p><p>在bash中运行hello，运行时bash先fork一个新进程，之后用execve加载执行hello，bash在用户模式下运行hello，输出完毕后Hello进程结束变为僵死进程，由bash回收。</p><h2 id="1-2-环境与工具"><a href="#1-2-环境与工具" class="headerlink" title="1.2 环境与工具"></a>1.2 环境与工具</h2><h3 id="1-2-1-硬件环境"><a href="#1-2-1-硬件环境" class="headerlink" title="1.2.1 硬件环境"></a>1.2.1 硬件环境</h3><p>X64 CPU；2GHz；2G RAM；256GHD Disk 以上</p><h3 id="1-2-2-软件环境"><a href="#1-2-2-软件环境" class="headerlink" title="1.2.2 软件环境"></a>1.2.2 软件环境</h3><p>Windows10 64位; VMWARE14; Ubuntu 16.04</p><h3 id="1-2-3-开发工具"><a href="#1-2-3-开发工具" class="headerlink" title="1.2.3 开发工具"></a>1.2.3 开发工具</h3><p>Vmware 14；Ubuntu 16.04 LTS 64 位；CodeBlocks；vi/ gpedit+gcc，EDB，VScode</p><h2 id="1-3-中间结果"><a href="#1-3-中间结果" class="headerlink" title="1.3 中间结果"></a>1.3 中间结果</h2><div class="table-container"><table><thead><tr><th>hello.c</th><th>源c文件</th></tr></thead><tbody><tr><td>hello.i</td><td>预处理后的c源文件</td></tr><tr><td>hello.s</td><td>编译后的汇编文件</td></tr><tr><td>hello.o</td><td>汇编后的可重定位目标文件</td></tr><tr><td>hello.out</td><td>可执行程序</td></tr></tbody></table></div><h2 id="1-4-本章小结"><a href="#1-4-本章小结" class="headerlink" title="1.4 本章小结"></a>1.4 本章小结</h2><p>本章简要说明hello的P2P 020 过程，列出开发环境及论文过程中的中间结果。</p><h1 id="第2章-预处理"><a href="#第2章-预处理" class="headerlink" title="第2章 预处理"></a>第2章 预处理</h1><h2 id="2-1-预处理的概念与作用"><a href="#2-1-预处理的概念与作用" class="headerlink" title="2.1 预处理的概念与作用"></a>2.1 预处理的概念与作用</h2><p>预处理是指在程序源代码被翻译为目标代码的过程中，在编译之前的工作，对一个源文件进行编译时， 系统将自动引用预处理程序对源程序中的预处理部分作处理， 处理完毕自动进入对源程序的编译。</p><p>Ｃ语言提供了多种预处理功能，如宏定义、文件包含、 条件编译等。</p><p>#if/#ifdef/#ifndef/#else/#elif/#endif（条件编译）、#define（宏定义）、#include（源文件包含）、#line（行控制）、#error（错误指令）、#pragma（和实现相关的杂注）以及单独的#（空指令）</p><h2 id="2-2在Ubuntu下预处理的命令"><a href="#2-2在Ubuntu下预处理的命令" class="headerlink" title="2.2在Ubuntu下预处理的命令"></a>2.2在Ubuntu下预处理的命令</h2><p>gcc -E hello.c -o hello.i</p><p>​    <img src="https://img-blog.csdnimg.cn/20181231223233808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/20181231223233806.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="2-3-Hello的预处理结果解析"><a href="#2-3-Hello的预处理结果解析" class="headerlink" title="2.3 Hello的预处理结果解析"></a>2.3 Hello的预处理结果解析</h2><p>Hello.c经预处理后变为hello.i ,实际是一个搜罗各家武功最后另成一派的过程。hello.c中的预处理指令是</p><p>#include <stdio.h></stdio.h></p><p>#include <unistd.h></unistd.h></p><p>#include <stdlib.h></stdlib.h></p><p>而之后程序使用的函数，均是这三个库里的内容，预处理就是把程序具体引用库函数的代码与c文件合在一起。</p><h2 id="2-4-本章小结"><a href="#2-4-本章小结" class="headerlink" title="2.4 本章小结"></a>2.4 本章小结</h2><p>预处理在编译前开始，这个过程并不对程序的源代码进行解析，但它把源代码分割或处理成为特定的单位——预处理记号。</p><p>c语言的预处理会展开以#起始的行，试图解释为预处理指令，预处理指令一般被用来使源代码在不同的执行环境中被方便的修改或者编译。</p><h1 id="第3章-编译"><a href="#第3章-编译" class="headerlink" title="第3章 编译"></a>第3章 编译</h1><h2 id="3-1-编译的概念与作用"><a href="#3-1-编译的概念与作用" class="headerlink" title="3.1 编译的概念与作用"></a>3.1 编译的概念与作用</h2><p>编译(compilation , compile) 1、利用编译程序从源语言编写的源程序产生目标程序的过程。 2、用编译程序产生目标程序的动作。 编译就是把高级语言变成计算机可以识别的2进制语言，计算机只认识1和0，编译程序把人们熟悉的语言换成2进制的。 编译程序把一个源程序翻译成目标程序的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。（但此处编译单指由预处理后文件到汇编文件的过程。）</p><p>把预处理完的文件进行一系列语法分析及优化后生成相应的汇编文件</p><h2 id="3-2-在Ubuntu下编译的命令"><a href="#3-2-在Ubuntu下编译的命令" class="headerlink" title="3.2 在Ubuntu下编译的命令"></a>3.2 在Ubuntu下编译的命令</h2><p>gcc -S hello.i -o hello.s</p><p><img src="https://img-blog.csdnimg.cn/20181231223233852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/20181231223233860.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="3-3-Hello的编译结果解析"><a href="#3-3-Hello的编译结果解析" class="headerlink" title="3.3 Hello的编译结果解析"></a>3.3 Hello的编译结果解析</h2><p>\3. 3. 1 数据类型</p><p> 1.整型数据</p><p> <img src="https://img-blog.csdnimg.cn/20181231223233886.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> Sleepsecs整型全局变量，占四个字节，.long 声明一个32位的数，相当于赋值操作，</p><p> <img src="https://img-blog.csdnimg.cn/20181231223234210.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 对sleepsecs取值</p><p>​      <img src="https://img-blog.csdnimg.cn/20181231223234208.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>​    Main函数的参数之一，命令行个数int argc</p><p>​    <img src="https://img-blog.csdnimg.cn/20181231223234272.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>​    i为循环辅助变量，int i的位置</p><p>   2.字符串</p><p>   <img src="https://img-blog.csdnimg.cn/20181231223234290.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>   两个字符串类型均在只读段中，属于字符串常量</p><p>   3.字符串指针</p><p><img src="https://img-blog.csdnimg.cn/20181231223234304.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>\3. 3. 2 操作</p><p>   1.算术操作：</p><p>   <img src="https://img-blog.csdnimg.cn/20181231223234322.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>   让循环控制变量加一</p><p>   2.赋值操作：</p><p>​        <img src="https://img-blog.csdnimg.cn/20181231223234319.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>   为循环控制变量i赋初值0</p><p>   3.关系操作</p><p>​        <img src="https://img-blog.csdnimg.cn/20181231223234377.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>   判断是否argc！=3</p><p>​        <img src="https://img-blog.csdnimg.cn/20181231223234372.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>   判断是否i&lt;10</p><p> 4.数组操作</p><p>   <img src="https://img-blog.csdnimg.cn/20181231223234701.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>   从数组中取值，数组存储在栈中，利用%rbp来访问数组中的值</p><p>\3. 3. 3控制转移</p><p>​        <img src="https://img-blog.csdnimg.cn/20181231223234703.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>   If（argc！=3）输出字符串后退出。否则进入循环</p><p>   <img src="https://img-blog.csdnimg.cn/20181231223234699.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>   为循环控制变量i赋初值0</p><p>   <img src="https://img-blog.csdnimg.cn/20181231223234694.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>   跳出循环的条件判断 若i&lt;=9则继续进入循环内容（L4）</p><p>   <img src="https://img-blog.csdnimg.cn/20181231223234724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>   L4完成后i++</p><p>   完成for(i=0;i&lt;10;i++)的架构</p><p>\3. 3. 4函数操作</p><p>   <img src="https://img-blog.csdnimg.cn/20181231223234832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>   通过call指令来调用函数</p><p>   <img src="https://img-blog.csdnimg.cn/20181231223234829.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>   ret指令使函数返回 返回值存储在%rax中</p><h2 id="3-4-本章小结"><a href="#3-4-本章小结" class="headerlink" title="3.4 本章小结"></a>3.4 本章小结</h2><p>   本章将经过预处理的.i文件编译成汇编文件.s，体现了由高级语言到汇编语言的转换过程，说明了其中的各种操作和数据是怎样在汇编语言中实现的。汇编是由高级语言到机器语言必不可少的一环，理解汇编语言的架构，是对机器的又一层理解，对今后的调试与优化工作有很大益处。</p><h1 id="第4章-汇编"><a href="#第4章-汇编" class="headerlink" title="第4章 汇编"></a>第4章 汇编</h1><h2 id="4-1-汇编的概念与作用"><a href="#4-1-汇编的概念与作用" class="headerlink" title="4.1 汇编的概念与作用"></a>4.1 汇编的概念与作用</h2><p>​    由汇编器将汇编文件翻译成机器指令，并将这些机器指令打包为可重定位目标程序</p><h2 id="4-2-在Ubuntu下汇编的命令"><a href="#4-2-在Ubuntu下汇编的命令" class="headerlink" title="4.2 在Ubuntu下汇编的命令"></a>4.2 在Ubuntu下汇编的命令</h2><p>​    <img src="https://img-blog.csdnimg.cn/2018123122323514.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/20181231223235156.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="4-3-可重定位目标elf格式"><a href="#4-3-可重定位目标elf格式" class="headerlink" title="4.3 可重定位目标elf格式"></a>4.3 可重定位目标elf格式</h2><p><img src="https://img-blog.csdnimg.cn/20181231223236514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>Elf头记录了魔数、文件类型、系统架构等信息。</p><p><img src="https://img-blog.csdnimg.cn/20181231223245202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>节头表通过数组实现，每个数组项包含一个节的信息。各个节构成了程序头表中定义的各段的内容。</p><p>.rela.text的link与info分别是符号表与代码段，表示将利用符号表在重定位时修改代码段</p><p><img src="https://img-blog.csdnimg.cn/20181231223238848.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>因全局变量定要经过重定义，这里以全局变量sleepsecs为例。在.rela.text中sleepsecs的offset是0x5c，表示需要修改的在.text段的0x5c处，在之后链接时要将sleepsecs链接到这里，而sleepsecs在符号表中的位置为0x9，重定位的类型为0x2。</p><p><img src="https://img-blog.csdnimg.cn/20181231223238981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>Symbol存放着所有全局符号</p><h2 id="4-4-Hello-o的结果解析"><a href="#4-4-Hello-o的结果解析" class="headerlink" title="4.4 Hello.o的结果解析"></a>4.4 Hello.o的结果解析</h2><p><img src="https://img-blog.csdnimg.cn/20181231223249348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>总体来讲反汇编结果和第三章的汇编代码差别不大，主要差别为</p><ol><li>函数调用方面：汇编语言中call指令后直接跟函数名称，而反汇编后的代码call后是代码行索引。</li><li>分支转移方面：汇编语言中jmp指令后直接跟标签名称，而反汇编后的代码jmp后是代码行索引。</li><li>反汇编后得到的代码中，每一个需要重定位的符号都以类型+名称形式显示出来。</li></ol><h2 id="4-5-本章小结"><a href="#4-5-本章小结" class="headerlink" title="4.5 本章小结"></a>4.5 本章小结</h2><p>本章表现了汇编语言转化为机器语言并被打包为可重定位目标程序的过程，揭示了机器代码与汇编语言的联系与映射，处理重定位信息的方法。为下一步链接做好准备。</p><h1 id="第5章-链接"><a href="#第5章-链接" class="headerlink" title="第5章 链接"></a>第5章 链接</h1><h2 id="5-1-链接的概念与作用"><a href="#5-1-链接的概念与作用" class="headerlink" title="5.1 链接的概念与作用"></a>5.1 链接的概念与作用</h2><p>​    每个模块都有自己的代码、数据（初始化全局变量、未初始化全 局变量、静态变量、局部变量），链接便是合并可重定位目标文件相同的节，来让程序变为一个较小的源文件的集合。</p><h2 id="5-2-在Ubuntu下链接的命令"><a href="#5-2-在Ubuntu下链接的命令" class="headerlink" title="5.2 在Ubuntu下链接的命令"></a>5.2 在Ubuntu下链接的命令</h2><p><img src="https://img-blog.csdnimg.cn/20181231223239218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/20181231223239292.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="5-3-可执行目标文件hello的格式"><a href="#5-3-可执行目标文件hello的格式" class="headerlink" title="5.3 可执行目标文件hello的格式"></a>5.3 可执行目标文件hello的格式</h2><p>分析hello的ELF格式，用readelf等列出其各段的基本信息，包括各段的起始地址，大小等信息。</p><p><img src="https://img-blog.csdnimg.cn/20181231223239672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20181231223239729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/20181231223240186.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>段头表标志每段的起始地址与大小</p><p><img src="https://img-blog.csdnimg.cn/20181231223241230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="5-4-hello的虚拟地址空间"><a href="#5-4-hello的虚拟地址空间" class="headerlink" title="5.4 hello的虚拟地址空间"></a>5.4 hello的虚拟地址空间</h2><p>  <img src="https://img-blog.csdnimg.cn/20181231223245313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>.plt段，PLT（Procedure Linkage Table）表每一项都是一小段代码，对应于本运行模块要引用的一个全局函数。</p><p><img src="https://img-blog.csdnimg.cn/2018123122324460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>.rodata 只读数据段</p><p><img src="https://img-blog.csdnimg.cn/20181231223251786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>.text 代码段</p><h2 id="5-5-链接的重定位过程分析"><a href="#5-5-链接的重定位过程分析" class="headerlink" title="5.5 链接的重定位过程分析"></a>5.5 链接的重定位过程分析</h2><p>对hello.o进行反汇编只有.text中main函数的汇编值与在特定位置标记的待重定位符号。而对hello.out进行反汇编发现是以.init与.plt与.text为结构的两段。</p><p>hello在进行重定位时参照.rela.text与.rela.data的表格数据，在.symtab中查找到相应的符号，插入到表中记录的段内索引中，其中共享库中的符号会创建.got与.got.plt项来记录重定位信息。</p><h2 id="5-6-hello的执行流程"><a href="#5-6-hello的执行流程" class="headerlink" title="5.6 hello的执行流程"></a>5.6 hello的执行流程</h2><div class="table-container"><table><thead><tr><th>_dl_start</th><th>0x00007f24:0ec259b0</th></tr></thead><tbody><tr><td>_dl_init</td><td>0x00007fa9:4304a740</td></tr><tr><td>_start</td><td>0x4004c0</td></tr><tr><td>init</td><td>0x400428</td></tr><tr><td>main</td><td>0x400510</td></tr><tr><td>_dl_fini</td><td>0x00007f24:0ec4a750</td></tr></tbody></table></div><h2 id="5-7-Hello的动态链接分析"><a href="#5-7-Hello的动态链接分析" class="headerlink" title="5.7 Hello的动态链接分析"></a>5.7 Hello的动态链接分析</h2><p>  （<em>以下格式自行编排，编辑时删除</em>）</p><p>分析hello程序的动态链接项目，通过edb调试，分析在dl_init前后，这些项目的内容变化。要截图标识说明。</p><p><img src="https://img-blog.csdnimg.cn/20181231223242606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>dl_init前程序的.plt表</p><p><img src="https://img-blog.csdnimg.cn/20181231223244246.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>dl_init前程序的.got表</p><h2 id="5-8-本章小结"><a href="#5-8-本章小结" class="headerlink" title="5.8 本章小结"></a>5.8 本章小结</h2><p>链接分为静态链接与动态链接，静态链接将目标文件和库文件打包至一个可执行文件中，动态链接在可执行目标文件中添加重定向记录，之后通过got表项和延迟绑定的方法实现对符号的重定向。</p><h1 id="第6章-hello进程管理"><a href="#第6章-hello进程管理" class="headerlink" title="第6章 hello进程管理"></a>第6章 hello进程管理</h1><h2 id="6-1-进程的概念与作用"><a href="#6-1-进程的概念与作用" class="headerlink" title="6.1 进程的概念与作用"></a>6.1 进程的概念与作用</h2><p>​    进程指程序的一次运行过程。更确切说，进程是具有独立功能的一个程序关于某个数据集合的一次运行活动，因而进程具有动态含义。同一个程序处理不同的数据就是不同的进程。进程有自己的生命周期。</p><p>​    操作系统以外的都属于“用户”的任务。</p><p>​    计算机处理的所有“用户”的任务由进程完成。</p><p>​    为强调进程完成的是用户的任务，通常将进程称为用户进程。</p><p>​    计算机系统中的任务通常就是指进程。</p><h2 id="6-2-简述壳Shell-bash的作用与处理流程"><a href="#6-2-简述壳Shell-bash的作用与处理流程" class="headerlink" title="6.2 简述壳Shell-bash的作用与处理流程"></a>6.2 简述壳Shell-bash的作用与处理流程</h2><p>shell 是一个交互型应用级程序，代表用户运行其他程序，shell 执行一系列的读/ 求值步骤：读步骤读取用户的命令行；求值步骤解析命令，代表用户运行</p><h2 id="6-3-Hello的fork进程创建过程"><a href="#6-3-Hello的fork进程创建过程" class="headerlink" title="6.3 Hello的fork进程创建过程"></a>6.3 Hello的fork进程创建过程</h2><p>​    用户在shell中输入./hello 学号 姓名 ，shell开始解析命令，先判断./hello是不是内置命令，发现不是后寻找当前目录中是否有名为hello的可执行文件。找到该文件后shell用fork（）创建一个子进程，更改该进程的进程组编号。</p><h2 id="6-4-Hello的execve过程"><a href="#6-4-Hello的execve过程" class="headerlink" title="6.4 Hello的execve过程"></a>6.4 Hello的execve过程</h2><p>​    在新进程中，使用execve（）加载并执行hello，将用户输入的参数列表与环境变量一同加载，之后开始运行hello的main函数中的输出。</p><h2 id="6-5-Hello的进程执行"><a href="#6-5-Hello的进程执行" class="headerlink" title="6.5 Hello的进程执行"></a>6.5 Hello的进程执行</h2><p>Hello进程在创建后运行在用户模式，而hello的上下文一直保存在内核中，进程上下文实际上是进程执行活动全过程的静态描述。我们把已执行过的进程指令和数据在相关寄存器与堆栈中的内容称为上文，把正在执行的指令和数据在寄存器和堆栈中的内容称为正文，把待执行的指令和数据在寄存器与堆栈中的内容称为下文。具体的说，进程上下文包括计算机系统中与执行该进程有关的各种寄存器（例如通用寄存器，程序计数器PC，程序状态字寄存器PS等）的值，程序段在经过编译过后形成的机器指令代码集，数据集及各种堆栈值PCB结构。这里，有关寄存器和栈区的内容是重要的。当系统调用和异常处理出现时，hello进程会陷入内核空间。此时，我们称内核“代表进程执行”并处于进程上下文。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出的时候，程序恢复在用户空间继续执行。</p><p>进程在大多数情况下是并行的，并行的进程逻辑流在时间上重叠，形成并发流。因此处理器会让并发的各个进程轮流进行，这就是多任务，一个进程只执行控制流的一部分所需的时间段就是一个时间片。一个进程与其他进程一起工作的多任务模式就是时间分片。</p><p><img src="https://img-blog.csdnimg.cn/20181231223246935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>在程序执行printf时引发系统调用，hello进程陷入内核运行，当printf函数结束后在将hello进程返回到用户模式中。当程序运行sleep或某个进程要抢占当前进程执行时就要进行上下文切换。首先保存当前进程的上下文，之后恢复新进程的上下文，最后内核将控制传递给新进程，这就是一个调度的过程。</p><h2 id="6-6-hello的异常与信号处理"><a href="#6-6-hello的异常与信号处理" class="headerlink" title="6.6 hello的异常与信号处理"></a>6.6 hello的异常与信号处理</h2><p>（<em>以下格式自行编排，编辑时删除</em>）</p><p> hello执行过程中会出现哪几类异常，会产生哪些信号，又怎么处理的。</p><p> 程序运行过程中可以按键盘，如不停乱按，包括回车，Ctrl-Z，Ctrl-C等，Ctrl-z后可以运行ps jobs pstree fg kill 等命令，请分别给出各命令及运行结截屏，说明异常与信号的处理。</p><p><img src="https://img-blog.csdnimg.cn/20181231223241592.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>输入Ctrl+c后shell发出一个SIGINT中断信号，hello在接受到信号后终止。</p><p><img src="https://img-blog.csdnimg.cn/20181231223243542.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>输入Ctrl+z后shell发出一个SIGSTP停止信号，hello在接受到信号后暂停。</p><p><img src="https://img-blog.csdnimg.cn/20181231223245259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>进程停止后用kill -9 给hello进程发送一个SIGKILL终止信号，hello进程终止。</p><h2 id="6-7本章小结"><a href="#6-7本章小结" class="headerlink" title="6.7本章小结"></a>6.7本章小结</h2><p>​    本章总结了进程在shell中的工作流程，简单介绍shell执行进程，调度进程，异常处理的过程。还具体举了几个信号体现shell对于异常的处理方法。</p><h1 id="第7章-hello的存储管理"><a href="#第7章-hello的存储管理" class="headerlink" title="第7章 hello的存储管理"></a>第7章 hello的存储管理</h1><h2 id="7-1-hello的存储器地址空间"><a href="#7-1-hello的存储器地址空间" class="headerlink" title="7.1 hello的存储器地址空间"></a>7.1 hello的存储器地址空间</h2><p>逻辑地址：</p><p>1、在有地址变换功能的计算机中,访问指令给出的地址 (操作数) 叫逻辑地址,也叫相对地址。要经过寻址方式的计算或变换才得到内存储器中的物理地址。</p><p>2、把用户程序中使用的地址称为相对地址即逻辑地址。</p><p>3、逻辑地址由两个16位的地址分量构成，一个为段基值，另一个为偏移量。两个分量均为无符号数编码。</p><p>地址空间: 非负整数地址的有序集合 {0, 1, 2, 3 … } 如果地址空间中的整数是连续的，称为线性地址空间</p><p>虚拟地址空间: N = 2n 个虚拟地址的集合 {0, 1, 2, 3, …, N-1}</p><p>物理地址空间: M = 2m 个物理内存地址的集合 {0, 1, 2, 3, …, M-1}</p><h2 id="7-2-Intel逻辑地址到线性地址的变换-段式管理"><a href="#7-2-Intel逻辑地址到线性地址的变换-段式管理" class="headerlink" title="7.2 Intel逻辑地址到线性地址的变换-段式管理"></a>7.2 Intel逻辑地址到线性地址的变换-段式管理</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wLWJsb2cuY3Nkbi5uZXQvaW1hZ2VzL3BfYmxvZ19jc2RuX25ldC9kbzJqaWFuZy9FbnRyeUltYWdlcy8yMDA5MDkwMi8zLmpwZw?x-oss-process=image/format,png" alt="https://p-blog.csdn.net/images/p_blog_csdn_net/do2jiang/EntryImages/20090902/3.jpg"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>首先，给定一个完整的逻辑地址[段选择符：段内偏移地址]，</p><p>1、看段选择符的T1=0还是1，知道当前要转换是GDT中的段，还是LDT中的段，再根据相应寄存器，得到其地址和大小。我们就有了一个数组了。</p><p>2、拿出段选择符中前13位，可以在这个数组中，查找到对应的段描述符，这样，它了Base，即基地址就知道了。</p><p>3、把Base + offset，就是要转换的线性地址了。 还是挺简单的，对于软件来讲，原则上就需要把硬件转换所需的信息准备好，就可以让硬件来完成这个转换了。</p><h2 id="7-3-Hello的线性地址到物理地址的变换-页式管理"><a href="#7-3-Hello的线性地址到物理地址的变换-页式管理" class="headerlink" title="7.3 Hello的线性地址到物理地址的变换-页式管理"></a>7.3 Hello的线性地址到物理地址的变换-页式管理</h2><p><img src="https://img-blog.csdnimg.cn/20181231223244404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>   分页单元中，页目录是唯一的，它的地址放在CPU的cr3寄存器中，是进行地址转换的开始点。</p><p>   每一个活动的进程，因为都有其独立的对应的虚似内存（页目录也是唯一的），那么它也对应了一个独立的页目录地址。——运行一个进程，需要将它的页目录地址放到cr3寄存器中，将别个的保存下来。</p><p>   每一个32位的线性地址被划分为三部份，面目录索引(10位)：页表索引(10位)：偏移(12位) 依据以下步骤进行转换：</p><p>(1)   从cr3中取出进程的页目录地址（操作系统负责在调度进程的时候，把这个地址装入对应寄存器）；</p><p>(2)   根据线性地址前十位，在数组中，找到对应的索引项，因为引入了二级管理模式，页目录中的项，不再是页的地址，而是一个页表的地址。（又引入了一个数组），页的地址被放到页表中去了。</p><p>(3)   根据线性地址的中间十位，在页表（也是数组）中找到页的起始地址；</p><p>(4)   将页的起始地址与线性地址中最后12位相加</p><h2 id="7-4-TLB与四级页表支持下的VA到PA的变换"><a href="#7-4-TLB与四级页表支持下的VA到PA的变换" class="headerlink" title="7.4 TLB与四级页表支持下的VA到PA的变换"></a>7.4 TLB与四级页表支持下的VA到PA的变换</h2><p><img src="https://img-blog.csdnimg.cn/20181231223247833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>VA由VPN、VPO两部分构成，VPN用于查找TLB中的页，VPN被分为TLBI与TLBT，TLBI为快表中组索引，TLBT为标志，快表命中后将PPN与VPO组合获得PA，否则从慢表中寻找PPN再组合成为PA。在四级页表中VPN被分为四份，前三个页表存的都是下一级页表的地址，最后一级页表才是PPN。</p><h2 id="7-5-三级Cache支持下的物理内存访问"><a href="#7-5-三级Cache支持下的物理内存访问" class="headerlink" title="7.5 三级Cache支持下的物理内存访问"></a>7.5 三级Cache支持下的物理内存访问</h2><p><img src="https://img-blog.csdnimg.cn/20181231223247803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>MMU先从L1中根据PA的偏移、索引、标记找寻数据，若不命中，再进入L2，L3，查找，都不命中就从主存中读取数据。</p><h2 id="7-6-hello进程fork时的内存映射"><a href="#7-6-hello进程fork时的内存映射" class="headerlink" title="7.6 hello进程fork时的内存映射"></a>7.6 hello进程fork时的内存映射</h2><p> 为新进程创建虚拟内存 </p><p>创建当前进程的的mm_struct, vm_area_struct和页表的原样副 本. </p><p>两个进程中的每个页面都标记为只读，</p><p>两个进程中的每个区域结构（vm_area_struct）都标记为私有的 写时复制（COW）</p><p> 在新进程中返回时，新进程拥有与调用fork进程相同的虚拟 内存</p><p> 随后的写操作通过写时复制机制创建新页面</p><h2 id="7-7-hello进程execve时的内存映射"><a href="#7-7-hello进程execve时的内存映射" class="headerlink" title="7.7 hello进程execve时的内存映射"></a>7.7 hello进程execve时的内存映射</h2><p>execve函数在当前进程 中加载并运行程序 hello.out的步骤:</p><p>      删除已存在的用户区域</p><p>      创建新的区域结构 </p><p>代码和初始化数据映射 到.text和.data区（目标 文件提供） </p><p>.bss和栈映射到匿名文 件</p><p>      设置PC，指向代码区域 的入口点 </p><p>Linux根据需要换入代码 和数据页面</p><p><img src="https://img-blog.csdnimg.cn/20181231223251970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="7-8-缺页故障与缺页中断处理"><a href="#7-8-缺页故障与缺页中断处理" class="headerlink" title="7.8 缺页故障与缺页中断处理"></a>7.8 缺页故障与缺页中断处理</h2><p>缺页故障会产生一个缺页中断，这是缺页异常处理程序会选择页表中的一个页并将它牺牲掉，从磁盘中读取缺失的页放到内存的页表中。</p><h2 id="7-9动态存储分配管理"><a href="#7-9动态存储分配管理" class="headerlink" title="7.9动态存储分配管理"></a>7.9动态存储分配管理</h2><p>​    在程序运行时程序员使用 动态内存分配器 (比如 malloc) 获得虚拟内存.动态内存分配器维护着一个进程的虚拟内存区域，称为堆</p><p>​    分配器将堆视为一组不同大小的块 (blocks)的集合来维护，每个块要么是已分配的，要么是空闲的。 </p><p>分配器的类型 </p><p>显式分配器 : 要求应用显式地释放任何已分配的块  例如，C语言中的 malloc 和 free </p><p>隐式分配器 : 应用检测到已分配块不再被程序所使用，就释放 这个块  比如Java，ML和Lisp等高级语言中的垃圾收集 (garbage collection)</p><p>​    动态内存分配器在分配时采取记录空闲块的方法</p><p>​    方法 1: 隐式空闲链表 (Implicit list) 通过头部中的大小字 段—隐含地连接所有块</p><p>​    <img src="https://img-blog.csdnimg.cn/20181231223241230.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>  方法 2: 显式空闲链表 (Explicit list) 在空闲块中使用指针</p><p><img src="https://img-blog.csdnimg.cn/20181231223241583.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>  方法 3: 分离的空闲列表 (Segregated free list)  按照大小分类，构成不同大小的空闲链表</p><p>  方法 4: 块按大小排序  在每个空闲块中使用一个带指针的平衡树，并使用长度作为权值</p><h2 id="7-10本章小结"><a href="#7-10本章小结" class="headerlink" title="7.10本章小结"></a>7.10本章小结</h2><p>​    本章介绍了利用虚拟内存空间访存的过程，由页到块，由虚拟地址到物理地址。虚拟地址更为进程的创建与加载执行提供了极大的便利。动态存储分配在程序运行的过程中十分必要，不同的分配策略也会影响分配的时间空间效率。</p><h1 id="第8章-hello的IO管理"><a href="#第8章-hello的IO管理" class="headerlink" title="第8章 hello的IO管理"></a>第8章 hello的IO管理</h1><h2 id="8-1-Linux的IO设备管理方法"><a href="#8-1-Linux的IO设备管理方法" class="headerlink" title="8.1 Linux的IO设备管理方法"></a>8.1 Linux的IO设备管理方法</h2><p>在分时并行多任务系统中，为了合理利用系统设备，达到一定的目标，不允许进程自行决定设备的使用，而是由系统按一定原则统一分配、管理。进程要进行IO操作时，需向操作系统提出IO请求，然后由操作系统根据系统当前的设备使用状况，按照一定的策略，决定对改进程的设备分配。设备的应用领域不同，其物理特性各异，但某些设备之间具有共性，为了简化对设备的管理，可对设备分类，或对同类设备采用相同的管理策略，比如Linux主要将外部IO设备分为字符设备和块设备（又被称为主设备），而同类设备又可能同时存在多个，故而要定位具体设备还需提供“次设备号”。</p><p>根据主设备号+次设备号可以去相应的设备开关表中定位具体的设备驱动程序。 内核和设备驱动程序的接口是块设备开关表和字符设备开关表。每一种设备类型在表中占用一个表项，每个表项含有若干数据项，其中有一项为该类设备驱动程序入口地址，在系统调用时引导核心转向适当的驱动程序接口。</p><p>Linux系统为各类设备分别配置不同的驱动程序，在用户程序中通过文件操作方式使用设备，如open\close\read\write等，由文件系统根据用户程序指令转向调用具体的设备驱动程序。</p><p>对设备特殊文件的系统调用，根据文件类型转入块设备开关表或字符设备开关表进行打开、关闭设备的操作，字符设备特殊文件的系统调用read、write转向字符设备开关表中指示的设备驱动程序，而对普通文件或目录文件的read\write系统调用则通过高速缓冲模块（缓冲区）转向设备驱动模块中的strategy过程。Linux中关于不同设备种类的管理架构如下</p><p><img src="https://img-blog.csdnimg.cn/20181231223247875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzQ3NzQz,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="8-2-简述Unix-IO接口及其函数"><a href="#8-2-简述Unix-IO接口及其函数" class="headerlink" title="8.2 简述Unix IO接口及其函数"></a>8.2 简述Unix IO接口及其函数</h2><p>open函数 函数原型 int open(char * path,int oflag,…)     </p><p>返回值是一个文件描述符  path顾名思义就是文件名 oflage文件是打开方式  第三个形参应用于创建文件时使用 /<em>创建文件其实还有一个create函数使用 以及openat由于还未使用过这个函数和open的差异 所以不在此处累赘</em>/     open函数 使用if 判断的时候 注意小细节</p><p>read函数  函数原型  ssize_t  read(int fd ,  void* buf , size_t nbytes)  </p><p>返回值是文件读取字节数 在好几种情况下会出现返回值不等于文件读取字节数 也就是第三个参数nbytes的情况 第二个形参buf读取到buf的内存 文件偏移量(current file offset)受改变</p><p>write函数  函数原型 ssize_t write(int fd , const void* buf, size_t nbytes) </p><p>返回值是文件写入字节数  fd是文件描述符 将buf内容写入nbytes个字节到文件 但这里需要注意默认情况是需要在系统队列中等待写入（打开方式不同也会不同）  //以上三个出错都返回-1</p><p>lseek函数off_t lseek(int fd, off_t offset , int whence) </p><p>返回值成功函数返回新的文件偏移量 失败-1  fd文件描述符  off_t是有符号的整数 whence其实是和off_t配套使用的 SEEK_SET文件开始处  SEEK_CUR当前值的相对位置 SEEK_END文件长度+-</p><p>close函数原型 int close(int fd)  </p><p>返回值 成功返回0 失败—1  关闭文件描述符</p><h2 id="8-3-printf的实现分析"><a href="#8-3-printf的实现分析" class="headerlink" title="8.3 printf的实现分析"></a>8.3 printf的实现分析</h2><p>从vsprintf生成显示信息，到write系统函数，到陷阱-系统调用 int 0x80或syscall.</p><p>字符显示驱动子程序：从ASCII到字模库到显示vram（存储每一个点的RGB颜色信息）。</p><p>显示芯片按照刷新频率逐行读取vram，并通过信号线向液晶显示器传输每一个点（RGB分量）。</p><p>int printf(const char *fmt, …)</p><p>{</p><p>int i;</p><p>char buf[256];</p><p>va_list arg = (va_list)((char*)(&amp;fmt) + 4);</p><p>i = vsprintf(buf, fmt, arg);</p><p>write(buf, i);</p><p>return i;</p><p>} </p><p>vsprintf的作用就是格式化。它接受确定输出格式的格式字符串fmt。用格式字符串对个数变化的参数进行格式化，产生格式化输出。 va_list_arg是边长参数列表中的第一个参数的地址。</p><p>Write如下</p><p>​    write:</p><p>   mov eax, _NR_write</p><p>   mov ebx, [esp + 4]</p><p>   mov ecx, [esp + 8]</p><p>   int INT_VECTOR_SYS_CALL</p><p>之后调用sys_call输出</p><h2 id="8-4-getchar的实现分析"><a href="#8-4-getchar的实现分析" class="headerlink" title="8.4 getchar的实现分析"></a>8.4 getchar的实现分析</h2><p>异步异常-键盘中断的处理：键盘中断处理子程序。接受按键扫描码转成ascii码，保存到系统的键盘缓冲区。</p><p>getchar等调用read系统函数，通过系统调用读取按键ascii码，直到接受到回车键才返回。</p><p>getchar有一个int型的返回值.当程序调用getchar时.程序就等着用户按键.用户输入的字符被存放在键盘缓冲区中.直到用户按回车为止(回车字符也放在缓冲区中).当用户键入回车之后,getchar才开始从stdio流中每次读入一个字符.getchar函数的返回值是用户输入的第一个字符的ASCII码,如出错返回-1,且将用户输入的字符回显到屏幕.如用户在按回车之前输入了不止一个字符,其他字符会保留在键盘缓存区中,等待后续getchar调用读取.也就是说,后续的getchar调用不会等待用户按键,而直接读取缓冲区中的字符,直到缓冲区中的字符读完为后,才等待用户按键.</p><p>getch与getchar基本功能相同,差别是getch直接从键盘获取键值,不等待用户按回车,只要用户按一个键,getch就立刻返回, getch返回值是用户输入的ASCII码,出错返回-1.输入的字符不会回显在屏幕上.getch函数常用于程序调试中,在调试时,在关键位置显示有关的结果以待查看,然后用getch函数暂停程序运行,当按任意键后程序继续运行.</p><h2 id="8-5本章小结"><a href="#8-5本章小结" class="headerlink" title="8.5本章小结"></a>8.5本章小结</h2><p>​    Linux通过UnixI/O函数来实现主存与IO设备的数据转换。Linux系统使用UnixIO接口将IO设备看做文件进行访问与输出，来实现IO管理</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ol><li>hello.c先经过预处理变为hello.i</li><li>hello.i经过编译变为汇编文件hello.s</li><li>hello.s经过汇编变为可重定向目标文件hello.o</li><li>hello.o经过链接变为可执行目标文件hello.out</li><li>运行时bash先fork一个新进程，之后用execve加载执行hello，bash在用户模式下运行hello</li><li>Hello与其他进程并行执行，在被抢占或系统调用或异常情况后进入内核模式，之后在再回到用户模式，期间发生上下文切换。</li><li>Hello的printf与getchar函数由linux的IO管理得以与IO设备进行输入输出</li><li>Hello进程结束变为僵死进程，由bash回收</li></ol><p>一个简单的hello.c，想要需要计算机系统的诸多底层工作，系统各个组成部分的互相协调就像庞大机器的齿轮一样紧密。是以以后在编写或运行程序时，若能与机器相互理解，一定能事半功倍。</p><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>列出所有的中间产物的文件名，并予以说明起作用。</p><div class="table-container"><table><thead><tr><th>hello.c</th><th>源c文件</th></tr></thead><tbody><tr><td>hello.i</td><td>预处理后的c源文件</td></tr><tr><td>hello.s</td><td>编译后的汇编文件</td></tr><tr><td>hello.o</td><td>汇编后的可重定位目标文件</td></tr><tr><td>hello.out</td><td>可执行程序</td></tr></tbody></table></div><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://blog.csdn.net/roger_ranger/article/details/78473886">https://blog.csdn.net/roger_ranger/article/details/78473886</a> Linux内核：IO设备的抽象管理方式</p><p>[2]  <a href="https://www.cnblogs.com/chentest/p/5448483.html">https://www.cnblogs.com/chentest/p/5448483.html</a> 关于unix系统接口 普通文件io的小结</p><p>[3] <a href="https://www.cnblogs.com/pianist/p/3315801.html">https://www.cnblogs.com/pianist/p/3315801.html</a>  [转]printf 函数实现的深入剖析</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机系统大作业——Hello的一生&quot;&gt;&lt;a href=&quot;#计算机系统大作业——Hello的一生&quot; class=&quot;headerlink&quot; title=&quot;计算机系统大作业——Hello的一生&quot;&gt;&lt;/a&gt;计算机系统大作业——Hello的一生&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;摘 要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  本文以hello.c为例，探寻程序由代码一步步经过预处理、编译、链接、之后成为进程，并被系统进行管理的过程。从而窥探程序由出生到死去的过程中，计算机系统各个部分是如何协调工作的，随着hello.c的一步步变化逐渐理解机器的运行机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词：&lt;/strong&gt;计算机系统；P2P；程序运行全过程；             &lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://www.aoshuqiu.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="计算机系统" scheme="https://www.aoshuqiu.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="P2P" scheme="https://www.aoshuqiu.top/tags/P2P/"/>
    
      <category term="程序运行全过程" scheme="https://www.aoshuqiu.top/tags/%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>闲唠唠嗑</title>
    <link href="https://www.aoshuqiu.top/2020/08/01/hello-world/"/>
    <id>https://www.aoshuqiu.top/2020/08/01/hello-world/</id>
    <published>2020-08-01T14:25:20.167Z</published>
    <updated>2020-08-04T08:40:23.959Z</updated>
    
    <content type="html"><![CDATA[<p>博客终于配置得差不多，就随便写一些测试一下</p><p>最近有些闲下来了，为了防止自己报复性娱乐，开个博客提醒着。提醒自己弄弄专业，提醒自己多做事少想事。这段时间应该会多写点东西，毕竟还有个新鲜劲。不管以后还会不会有兴趣、精力，现在做事总是好的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博客终于配置得差不多，就随便写一些测试一下&lt;/p&gt;
&lt;p&gt;最近有些闲下来了，为了防止自己报复性娱乐，开个博客提醒着。提醒自己弄弄专业，提醒自己多做事少想事。这段时间应该会多写点东西，毕竟还有个新鲜劲。不管以后还会不会有兴趣、精力，现在做事总是好的。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="闲嗑" scheme="https://www.aoshuqiu.top/categories/%E9%97%B2%E5%97%91/"/>
    
    
  </entry>
  
</feed>
